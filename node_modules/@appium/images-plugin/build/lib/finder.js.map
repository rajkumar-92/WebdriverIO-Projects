{"version":3,"file":"finder.js","names":["MJSONWP_ELEMENT_KEY","W3C_ELEMENT_KEY","util","W3C_WEB_ELEMENT_IDENTIFIER","DEFAULT_FIX_IMAGE_TEMPLATE_SCALE","FLOAT_PRECISION","MAX_CACHE_ITEMS","MAX_CACHE_SIZE_BYTES","DEFAULT_SETTINGS","imageMatchThreshold","DEFAULT_MATCH_THRESHOLD","imageMatchMethod","fixImageFindScreenshotDims","fixImageTemplateSize","fixImageTemplateScale","defaultImageTemplateScale","DEFAULT_TEMPLATE_IMAGE_SCALE","checkForImageElementStaleness","autoUpdateImageElementPosition","imageElementTapStrategy","IMAGE_EL_TAP_STRATEGY_W3C","getMatchedImageResult","ImageElementFinder","driver","imgElCache","constructor","maxSize","LRU","max","sizeCalculation","el","template","length","setDriver","registerImageElement","imgEl","set","id","protoKey","isW3CProtocol","asElement","findByImage","b64Template","shouldCheckStaleness","multiple","ignoreDefaultImageTemplateScale","Error","settings","getSettings","threshold","visualize","log","info","getWindowSize","width","screenWidth","height","screenHeight","ensureTemplateSize","results","condition","b64Screenshot","scale","getScreenshotForImageFind","comparisonOpts","method","push","compareImages","MATCH_TEMPLATE_MODE","err","message","match","implicitWaitForCondition","_","isEmpty","errors","NoSuchElementError","elements","map","rect","score","visualization","JSON","stringify","ImageElement","registeredElements","imgObj","imageUtil","getJimpImage","tplWidth","tplHeight","bitmap","scaleToFit","getBuffer","MIME_PNG","toString","getScreenshot","Object","assign","warn","shotWidth","shotHeight","xScale","yScale","screenAR","shotAR","Math","round","scaleFactor","resize","opts","parseFloat","String","Number","imgTempObj","baseTempWidth","baseTempHeigh","scaledWidth","scaledHeight"],"sources":["../../lib/finder.js"],"sourcesContent":["import _ from 'lodash';\nimport LRU from 'lru-cache';\nimport {errors} from 'appium/driver';\nimport {util, imageUtil} from 'appium/support';\nimport {\n  ImageElement,\n  DEFAULT_TEMPLATE_IMAGE_SCALE,\n  IMAGE_EL_TAP_STRATEGY_W3C,\n} from './image-element';\nimport {MATCH_TEMPLATE_MODE, compareImages, DEFAULT_MATCH_THRESHOLD} from './compare';\nimport log from './logger';\n\nconst MJSONWP_ELEMENT_KEY = 'ELEMENT';\nconst W3C_ELEMENT_KEY = util.W3C_WEB_ELEMENT_IDENTIFIER;\nconst DEFAULT_FIX_IMAGE_TEMPLATE_SCALE = 1;\n// Used to compare ratio and screen width\n// Pixel is basically under 1080 for example. 100K is probably enough fo a while.\nconst FLOAT_PRECISION = 100000;\nconst MAX_CACHE_ITEMS = 100;\nconst MAX_CACHE_SIZE_BYTES = 1024 * 1024 * 40; // 40mb\n\nconst DEFAULT_SETTINGS = {\n  // value between 0 and 1 representing match strength, below which an image\n  // element will not be found\n  imageMatchThreshold: DEFAULT_MATCH_THRESHOLD,\n\n  // One of possible image matching methods.\n  // Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html\n  // for more details.\n  // TM_CCOEFF_NORMED by default\n  imageMatchMethod: '',\n\n  // if the image returned by getScreenshot differs in size or aspect ratio\n  // from the screen, attempt to fix it automatically\n  fixImageFindScreenshotDims: true,\n\n  // whether Appium should ensure that an image template sent in during image\n  // element find should have its size adjusted so the match algorithm will not\n  // complain\n  fixImageTemplateSize: false,\n\n  // whether Appium should ensure that an image template sent in during image\n  // element find should have its scale adjusted to display size so the match\n  // algorithm will not complain.\n  // e.g. iOS has `width=375, height=667` window rect, but its screenshot is\n  //      `width=750 × height=1334` pixels. This setting help to adjust the scale\n  //      if a user use `width=750 × height=1334` pixels's base template image.\n  fixImageTemplateScale: false,\n\n  // Users might have scaled template image to reduce their storage size.\n  // This setting allows users to scale a template image they send to Appium server\n  // so that the Appium server compares the actual scale users originally had.\n  // e.g. If a user has an image of 270 x 32 pixels which was originally 1080 x 126 pixels,\n  //      the user can set {defaultImageTemplateScale: 4.0} to scale the small image\n  //      to the original one so that Appium can compare it as the original one.\n  defaultImageTemplateScale: DEFAULT_TEMPLATE_IMAGE_SCALE,\n\n  // whether Appium should re-check that an image element can be matched\n  // against the current screenshot before clicking it\n  checkForImageElementStaleness: true,\n\n  // whether before clicking on an image element Appium should re-determine the\n  // position of the element on screen\n  autoUpdateImageElementPosition: false,\n\n  // which method to use for tapping by coordinate for image elements. the\n  // options are 'w3c' or 'mjsonwp'\n  imageElementTapStrategy: IMAGE_EL_TAP_STRATEGY_W3C,\n\n  // which method to use to save the matched image area in ImageElement class.\n  // It is used for debugging purpose.\n  getMatchedImageResult: false,\n};\n\nexport default class ImageElementFinder {\n  /** @type {ExternalDriver} */\n  driver;\n\n  /** @type {LRU<string,ImageElement>} */\n  imgElCache;\n\n  /**\n   *\n   * @param {ExternalDriver} driver\n   * @param {number} [maxSize]\n   */\n  constructor(driver, maxSize = MAX_CACHE_SIZE_BYTES) {\n    this.driver = driver;\n    this.imgElCache = new LRU({\n      max: MAX_CACHE_ITEMS,\n      maxSize,\n      sizeCalculation: (el) => el.template.length,\n    });\n  }\n\n  setDriver(driver) {\n    this.driver = driver;\n  }\n\n  /**\n   * @param {ImageElement} imgEl\n   * @returns {Element}\n   */\n  registerImageElement(imgEl) {\n    this.imgElCache.set(imgEl.id, imgEl);\n    const protoKey = this.driver.isW3CProtocol() ? W3C_ELEMENT_KEY : MJSONWP_ELEMENT_KEY;\n    return imgEl.asElement(protoKey);\n  }\n\n  /**\n   * @typedef FindByImageOptions\n   * @property {boolean} [shouldCheckStaleness=false] - whether this call to find an\n   * image is merely to check staleness. If so we can bypass a lot of logic\n   * @property {boolean} [multiple=false] - Whether we are finding one element or\n   * multiple\n   * @property {boolean} [ignoreDefaultImageTemplateScale=false] - Whether we\n   * ignore defaultImageTemplateScale. It can be used when you would like to\n   * scale b64Template with defaultImageTemplateScale setting.\n   */\n\n  /**\n   * Find a screen rect represented by an ImageElement corresponding to an image\n   * template sent in by the client\n   *\n   * @param {string} b64Template - base64-encoded image used as a template to be\n   * matched in the screenshot\n   * @param {FindByImageOptions} opts - additional options\n   *\n   * @returns {Promise<Element|Element[]|ImageElement>} - WebDriver element with a special id prefix\n   */\n  async findByImage(\n    b64Template,\n    {shouldCheckStaleness = false, multiple = false, ignoreDefaultImageTemplateScale = false}\n  ) {\n    if (!this.driver) {\n      throw new Error(`Can't find without a driver!`);\n    }\n    const settings = {...DEFAULT_SETTINGS, ...this.driver.settings.getSettings()};\n    const {\n      imageMatchThreshold: threshold,\n      imageMatchMethod,\n      fixImageTemplateSize,\n      fixImageTemplateScale,\n      defaultImageTemplateScale,\n      getMatchedImageResult: visualize,\n    } = settings;\n\n    log.info(`Finding image element with match threshold ${threshold}`);\n    if (!this.driver.getWindowSize) {\n      throw new Error(\"This driver does not support the required 'getWindowSize' command\");\n    }\n    const {width: screenWidth, height: screenHeight} = await this.driver.getWindowSize();\n\n    // someone might have sent in a template that's larger than the screen\n    // dimensions. If so let's check and cut it down to size since the algorithm\n    // will not work unless we do. But because it requires some potentially\n    // expensive commands, only do this if the user has requested it in settings.\n    if (fixImageTemplateSize) {\n      b64Template = await this.ensureTemplateSize(b64Template, screenWidth, screenHeight);\n    }\n\n    const results = [];\n    const condition = async () => {\n      try {\n        const {b64Screenshot, scale} = await this.getScreenshotForImageFind(\n          screenWidth,\n          screenHeight\n        );\n\n        b64Template = await this.fixImageTemplateScale(b64Template, {\n          defaultImageTemplateScale,\n          ignoreDefaultImageTemplateScale,\n          fixImageTemplateScale,\n          ...scale,\n        });\n\n        const comparisonOpts = {\n          threshold,\n          visualize,\n          multiple,\n        };\n        if (imageMatchMethod) {\n          comparisonOpts.method = imageMatchMethod;\n        }\n        if (multiple) {\n          results.push(\n            ...(await compareImages(\n              MATCH_TEMPLATE_MODE,\n              b64Screenshot,\n              b64Template,\n              comparisonOpts\n            ))\n          );\n        } else {\n          results.push(\n            await compareImages(MATCH_TEMPLATE_MODE, b64Screenshot, b64Template, comparisonOpts)\n          );\n        }\n        return true;\n      } catch (err) {\n        // if compareImages fails, we'll get a specific error, but we should\n        // retry, so trap that and just return false to trigger the next round of\n        // implicitly waiting. For other errors, throw them to get out of the\n        // implicit wait loop\n        if (err.message.match(/Cannot find any occurrences/)) {\n          return false;\n        }\n        throw err;\n      }\n    };\n\n    try {\n      await this.driver.implicitWaitForCondition(condition);\n    } catch (err) {\n      // this `implicitWaitForCondition` method will throw a 'Condition unmet'\n      // error if an element is not found eventually. In that case, we will\n      // handle the element not found response below. In the case where get some\n      // _other_ kind of error, it means something blew up totally apart from the\n      // implicit wait timeout. We should not mask that error and instead throw\n      // it straightaway\n      if (!err.message.match(/Condition unmet/)) {\n        throw err;\n      }\n    }\n\n    if (_.isEmpty(results)) {\n      if (multiple) {\n        return [];\n      }\n      throw new errors.NoSuchElementError();\n    }\n\n    const elements = results.map(({rect, score, visualization}) => {\n      log.info(`Image template matched: ${JSON.stringify(rect)}`);\n      return new ImageElement(b64Template, rect, score, visualization, this);\n    });\n\n    // if we're just checking staleness, return straightaway so we don't add\n    // a new element to the cache. shouldCheckStaleness does not support multiple\n    // elements, since it is a purely internal mechanism\n    if (shouldCheckStaleness) {\n      return elements[0];\n    }\n\n    const registeredElements = elements.map((imgEl) => this.registerImageElement(imgEl));\n\n    return multiple ? registeredElements : registeredElements[0];\n  }\n\n  /**\n   * Ensure that the image template sent in for a find is of a suitable size\n   *\n   * @param {string} b64Template - base64-encoded image\n   * @param {number} screenWidth - width of screen\n   * @param {number} screenHeight - height of screen\n   *\n   * @returns {Promise<string>} base64-encoded image, potentially resized\n   */\n  async ensureTemplateSize(b64Template, screenWidth, screenHeight) {\n    let imgObj = await imageUtil.getJimpImage(b64Template);\n    let {width: tplWidth, height: tplHeight} = imgObj.bitmap;\n\n    log.info(\n      `Template image is ${tplWidth}x${tplHeight}. Screen size is ${screenWidth}x${screenHeight}`\n    );\n    // if the template fits inside the screen dimensions, we're good\n    if (tplWidth <= screenWidth && tplHeight <= screenHeight) {\n      return b64Template;\n    }\n\n    log.info(\n      `Scaling template image from ${tplWidth}x${tplHeight} to match ` +\n        `screen at ${screenWidth}x${screenHeight}`\n    );\n    // otherwise, scale it to fit inside the screen dimensions\n    imgObj = imgObj.scaleToFit(screenWidth, screenHeight);\n    return (await imgObj.getBuffer(imageUtil.MIME_PNG)).toString('base64');\n  }\n\n  /**\n   * Get the screenshot image that will be used for find by element, potentially\n   * altering it in various ways based on user-requested settings\n   *\n   * @param {number} screenWidth - width of screen\n   * @param {number} screenHeight - height of screen\n   *\n   * @returns {Promise<Screenshot & {scale?: ScreenshotScale}>} base64-encoded screenshot and ScreenshotScale\n   */\n  async getScreenshotForImageFind(screenWidth, screenHeight) {\n    if (!this.driver.getScreenshot) {\n      throw new Error(\"This driver does not support the required 'getScreenshot' command\");\n    }\n    const settings = Object.assign({}, DEFAULT_SETTINGS, this.driver.settings.getSettings());\n    const {fixImageFindScreenshotDims} = settings;\n\n    let b64Screenshot = await this.driver.getScreenshot();\n\n    // if the user has requested not to correct for aspect or size differences\n    // between the screenshot and the screen, just return the screenshot now\n    if (!fixImageFindScreenshotDims) {\n      log.info(`Not verifying screenshot dimensions match screen`);\n      return {b64Screenshot};\n    }\n\n    if (screenWidth < 1 || screenHeight < 1) {\n      log.warn(\n        `The retrieved screen size ${screenWidth}x${screenHeight} does ` +\n          `not seem to be valid. No changes will be applied to the screenshot`\n      );\n      return {b64Screenshot};\n    }\n\n    // otherwise, do some verification on the screenshot to make sure it matches\n    // the screen size and aspect ratio\n    log.info('Verifying screenshot size and aspect ratio');\n\n    let imgObj = await imageUtil.getJimpImage(b64Screenshot);\n    let {width: shotWidth, height: shotHeight} = imgObj.bitmap;\n\n    if (shotWidth < 1 || shotHeight < 1) {\n      log.warn(\n        `The retrieved screenshot size ${shotWidth}x${shotHeight} does ` +\n          `not seem to be valid. No changes will be applied to the screenshot`\n      );\n      return {b64Screenshot};\n    }\n\n    if (screenWidth === shotWidth && screenHeight === shotHeight) {\n      // the height and width of the screenshot and the device screen match, which\n      // means we should be safe when doing template matches\n      log.info('Screenshot size matched screen size');\n      return {b64Screenshot};\n    }\n\n    // otherwise, if they don't match, it could spell problems for the accuracy\n    // of coordinates returned by the image match algorithm, since we match based\n    // on the screenshot coordinates not the device coordinates themselves. There\n    // are two potential types of mismatch: aspect ratio mismatch and scale\n    // mismatch. We need to detect and fix both\n\n    const scale = {xScale: 1.0, yScale: 1.0};\n\n    const screenAR = screenWidth / screenHeight;\n    const shotAR = shotWidth / shotHeight;\n    if (Math.round(screenAR * FLOAT_PRECISION) === Math.round(shotAR * FLOAT_PRECISION)) {\n      log.info(\n        `Screenshot aspect ratio '${shotAR}' (${shotWidth}x${shotHeight}) matched ` +\n          `screen aspect ratio '${screenAR}' (${screenWidth}x${screenHeight})`\n      );\n    } else {\n      log.warn(\n        `When trying to find an element, determined that the screen ` +\n          `aspect ratio and screenshot aspect ratio are different. Screen ` +\n          `is ${screenWidth}x${screenHeight} whereas screenshot is ` +\n          `${shotWidth}x${shotHeight}.`\n      );\n\n      // In the case where the x-scale and y-scale are different, we need to decide\n      // which one to respect, otherwise the screenshot and template will end up\n      // being resized in a way that changes its aspect ratio (distorts it). For example, let's say:\n      // this.getScreenshot(shotWidth, shotHeight) is 540x397,\n      // this.getDeviceSize(screenWidth, screenHeight) is 1080x1920.\n      // The ratio would then be {xScale: 0.5, yScale: 0.2}.\n      // In this case, we must should `yScale: 0.2` as scaleFactor, because\n      // if we select the xScale, the height will be bigger than real screenshot size\n      // which is used to image comparison by OpenCV as a base image.\n      // All of this is primarily useful when the screenshot is a horizontal slice taken out of the\n      // screen (for example not including top/bottom nav bars)\n      const xScale = (1.0 * shotWidth) / screenWidth;\n      const yScale = (1.0 * shotHeight) / screenHeight;\n      const scaleFactor = xScale >= yScale ? yScale : xScale;\n\n      log.warn(\n        `Resizing screenshot to ${shotWidth * scaleFactor}x${shotHeight * scaleFactor} to match ` +\n          `screen aspect ratio so that image element coordinates have a ` +\n          `greater chance of being correct.`\n      );\n      imgObj = imgObj.resize(shotWidth * scaleFactor, shotHeight * scaleFactor);\n\n      scale.xScale *= scaleFactor;\n      scale.yScale *= scaleFactor;\n\n      shotWidth = imgObj.bitmap.width;\n      shotHeight = imgObj.bitmap.height;\n    }\n\n    // Resize based on the screen dimensions only if both width and height are mismatched\n    // since except for that, it might be a situation which is different window rect and\n    // screenshot size like `@driver.window_rect #=>x=0, y=0, width=1080, height=1794` and\n    // `\"deviceScreenSize\"=>\"1080x1920\"`\n    if (screenWidth !== shotWidth && screenHeight !== shotHeight) {\n      log.info(\n        `Scaling screenshot from ${shotWidth}x${shotHeight} to match ` +\n          `screen at ${screenWidth}x${screenHeight}`\n      );\n      imgObj = imgObj.resize(screenWidth, screenHeight);\n\n      scale.xScale *= (1.0 * screenWidth) / shotWidth;\n      scale.yScale *= (1.0 * screenHeight) / shotHeight;\n    }\n\n    b64Screenshot = (await imgObj.getBuffer(imageUtil.MIME_PNG)).toString('base64');\n    return {b64Screenshot, scale};\n  }\n\n  /**\n   * @typedef ImageTemplateSettings\n   * @property {boolean} fixImageTemplateScale - fixImageTemplateScale in device-settings\n   * @property {number} defaultImageTemplateScale - defaultImageTemplateScale in device-settings\n   * @property {boolean} ignoreDefaultImageTemplateScale - Ignore defaultImageTemplateScale if it has true.\n   * If b64Template has been scaled to defaultImageTemplateScale or should ignore the scale,\n   * this parameter should be true. e.g. click in image-element module\n   * @property {number} xScale - Scale ratio for width\n   * @property {number} yScale - Scale ratio for height\n\n   */\n  /**\n   * Get a image that will be used for template maching.\n   * Returns scaled image if scale ratio is provided.\n   *\n   *\n   * @param {string} b64Template - base64-encoded image used as a template to be\n   * matched in the screenshot\n   * @param {ImageTemplateSettings} opts - Image template scale related options\n   *\n   * @returns {Promise<string>} base64-encoded scaled template screenshot\n   */\n  async fixImageTemplateScale(b64Template, opts) {\n    if (!opts) {\n      return b64Template;\n    }\n\n    let {\n      fixImageTemplateScale = false,\n      defaultImageTemplateScale = DEFAULT_TEMPLATE_IMAGE_SCALE,\n      ignoreDefaultImageTemplateScale = false,\n      xScale = DEFAULT_FIX_IMAGE_TEMPLATE_SCALE,\n      yScale = DEFAULT_FIX_IMAGE_TEMPLATE_SCALE,\n    } = opts;\n\n    if (ignoreDefaultImageTemplateScale) {\n      defaultImageTemplateScale = DEFAULT_TEMPLATE_IMAGE_SCALE;\n    }\n\n    // Default\n    if (defaultImageTemplateScale === DEFAULT_TEMPLATE_IMAGE_SCALE && !fixImageTemplateScale) {\n      return b64Template;\n    }\n\n    // Calculate xScale and yScale Appium should scale\n    if (fixImageTemplateScale) {\n      xScale *= defaultImageTemplateScale;\n      yScale *= defaultImageTemplateScale;\n    } else {\n      xScale = yScale = 1 * defaultImageTemplateScale;\n    }\n\n    // xScale and yScale can be NaN if defaultImageTemplateScale is string, for example\n    if (!parseFloat(String(xScale)) || !parseFloat(String(yScale))) {\n      return b64Template;\n    }\n\n    // Return if the scale is default, 1, value\n    if (\n      Math.round(xScale * FLOAT_PRECISION) ===\n        Math.round(DEFAULT_FIX_IMAGE_TEMPLATE_SCALE * FLOAT_PRECISION) &&\n      Math.round(\n        Number(\n          yScale * FLOAT_PRECISION ===\n            Math.round(DEFAULT_FIX_IMAGE_TEMPLATE_SCALE * FLOAT_PRECISION)\n        )\n      )\n    ) {\n      return b64Template;\n    }\n\n    let imgTempObj = await imageUtil.getJimpImage(b64Template);\n    let {width: baseTempWidth, height: baseTempHeigh} = imgTempObj.bitmap;\n\n    const scaledWidth = baseTempWidth * xScale;\n    const scaledHeight = baseTempHeigh * yScale;\n    log.info(\n      `Scaling template image from ${baseTempWidth}x${baseTempHeigh}` +\n        ` to ${scaledWidth}x${scaledHeight}`\n    );\n    log.info(`The ratio is ${xScale} and ${yScale}`);\n    imgTempObj = await imgTempObj.resize(scaledWidth, scaledHeight);\n    return (await imgTempObj.getBuffer(imageUtil.MIME_PNG)).toString('base64');\n  }\n}\n\nexport {W3C_ELEMENT_KEY, MJSONWP_ELEMENT_KEY, DEFAULT_SETTINGS, DEFAULT_FIX_IMAGE_TEMPLATE_SCALE};\n\n/**\n * @typedef {import('@appium/types').ExternalDriver} ExternalDriver\n * @typedef {import('@appium/types').Element} Element\n */\n\n/**\n * @typedef Screenshot\n * @property {string} b64Screenshot - base64 based screenshot string\n */\n\n/**\n * @typedef ScreenshotScale\n * @property {number} xScale - Scale ratio for width\n * @property {number} yScale - Scale ratio for height\n */\n"],"mappings":"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"}