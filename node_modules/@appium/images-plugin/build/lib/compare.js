"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MATCH_TEMPLATE_MODE = exports.MATCH_FEATURES_MODE = exports.GET_SIMILARITY_MODE = exports.DEFAULT_MATCH_THRESHOLD = void 0;
exports.compareImages = compareImages;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _driver = require("appium/driver");

var _opencv = require("@appium/opencv");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MATCH_FEATURES_MODE = 'matchFeatures';
exports.MATCH_FEATURES_MODE = MATCH_FEATURES_MODE;
const GET_SIMILARITY_MODE = 'getSimilarity';
exports.GET_SIMILARITY_MODE = GET_SIMILARITY_MODE;
const MATCH_TEMPLATE_MODE = 'matchTemplate';
exports.MATCH_TEMPLATE_MODE = MATCH_TEMPLATE_MODE;
const DEFAULT_MATCH_THRESHOLD = 0.4;
exports.DEFAULT_MATCH_THRESHOLD = DEFAULT_MATCH_THRESHOLD;

async function compareImages(mode, firstImage, secondImage, options = {}) {
  const img1 = Buffer.from(firstImage, 'base64');
  const img2 = Buffer.from(secondImage, 'base64');
  let result = null;

  switch (_lodash.default.toLower(mode)) {
    case MATCH_FEATURES_MODE.toLowerCase():
      try {
        result = await (0, _opencv.getImagesMatches)(img1, img2, options);
      } catch (err) {
        result = {
          count: 0
        };
      }

      break;

    case GET_SIMILARITY_MODE.toLowerCase():
      result = await (0, _opencv.getImagesSimilarity)(img1, img2, options);
      break;

    case MATCH_TEMPLATE_MODE.toLowerCase():
      result = await (0, _opencv.getImageOccurrence)(img1, img2, options);

      if (options.multiple) {
        return result.multiple.map(convertVisualizationToBase64);
      }

      break;

    default:
      throw new _driver.errors.InvalidArgumentError(`'${mode}' images comparison mode is unknown. ` + `Only ${JSON.stringify([MATCH_FEATURES_MODE, GET_SIMILARITY_MODE, MATCH_TEMPLATE_MODE])} modes are supported.`);
  }

  return convertVisualizationToBase64(result);
}

function convertVisualizationToBase64(element) {
  if (!_lodash.default.isEmpty(element.visualization)) {
    element.visualization = element.visualization.toString('base64');
  }

  return element;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNQVRDSF9GRUFUVVJFU19NT0RFIiwiR0VUX1NJTUlMQVJJVFlfTU9ERSIsIk1BVENIX1RFTVBMQVRFX01PREUiLCJERUZBVUxUX01BVENIX1RIUkVTSE9MRCIsImNvbXBhcmVJbWFnZXMiLCJtb2RlIiwiZmlyc3RJbWFnZSIsInNlY29uZEltYWdlIiwib3B0aW9ucyIsImltZzEiLCJCdWZmZXIiLCJmcm9tIiwiaW1nMiIsInJlc3VsdCIsIl8iLCJ0b0xvd2VyIiwidG9Mb3dlckNhc2UiLCJnZXRJbWFnZXNNYXRjaGVzIiwiZXJyIiwiY291bnQiLCJnZXRJbWFnZXNTaW1pbGFyaXR5IiwiZ2V0SW1hZ2VPY2N1cnJlbmNlIiwibXVsdGlwbGUiLCJtYXAiLCJjb252ZXJ0VmlzdWFsaXphdGlvblRvQmFzZTY0IiwiZXJyb3JzIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZWxlbWVudCIsImlzRW1wdHkiLCJ2aXN1YWxpemF0aW9uIiwidG9TdHJpbmciXSwic291cmNlcyI6WyIuLi8uLi9saWIvY29tcGFyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtlcnJvcnN9IGZyb20gJ2FwcGl1bS9kcml2ZXInO1xuaW1wb3J0IHtnZXRJbWFnZXNNYXRjaGVzLCBnZXRJbWFnZXNTaW1pbGFyaXR5LCBnZXRJbWFnZU9jY3VycmVuY2V9IGZyb20gJ0BhcHBpdW0vb3BlbmN2JztcblxuY29uc3QgTUFUQ0hfRkVBVFVSRVNfTU9ERSA9ICdtYXRjaEZlYXR1cmVzJztcbmNvbnN0IEdFVF9TSU1JTEFSSVRZX01PREUgPSAnZ2V0U2ltaWxhcml0eSc7XG5jb25zdCBNQVRDSF9URU1QTEFURV9NT0RFID0gJ21hdGNoVGVtcGxhdGUnO1xuXG5jb25zdCBERUZBVUxUX01BVENIX1RIUkVTSE9MRCA9IDAuNDtcblxuLyoqXG4gKiBQZXJmb3JtcyBpbWFnZXMgY29tcGFyaXNvbiB1c2luZyBPcGVuQ1YgZnJhbWV3b3JrIGZlYXR1cmVzLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCBib3RoIE9wZW5DViBmcmFtZXdvcmsgYW5kIG9wZW5jdjRub2RlanNcbiAqIG1vZHVsZSBhcmUgaW5zdGFsbGVkIG9uIHRoZSBtYWNoaW5lIHdoZXJlIEFwcGl1bSBzZXJ2ZXIgaXMgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIE9uZSBvZiBwb3NzaWJsZSBjb21wYXJpc29uIG1vZGVzOlxuICogbWF0Y2hGZWF0dXJlcywgZ2V0U2ltaWxhcml0eSwgbWF0Y2hUZW1wbGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpcnN0SW1hZ2UgLSBCYXNlNjQtZW5jb2RlZCBpbWFnZSBmaWxlLlxuICogQWxsIGltYWdlIGZvcm1hdHMsIHRoYXQgT3BlbkNWIGxpYnJhcnkgaXRzZWxmIGFjY2VwdHMsIGFyZSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2Vjb25kSW1hZ2UgLSBCYXNlNjQtZW5jb2RlZCBpbWFnZSBmaWxlLlxuICogQWxsIGltYWdlIGZvcm1hdHMsIHRoYXQgT3BlbkNWIGxpYnJhcnkgaXRzZWxmIGFjY2VwdHMsIGFyZSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVGhlIGNvbnRlbnQgb2YgdGhpcyBkaWN0aW9uYXJ5IGRlcGVuZHNcbiAqIG9uIHRoZSBhY3R1YWwgYG1vZGVgIHZhbHVlLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gb24gYEBhcHBpdW0vc3VwcG9ydGBcbiAqIG1vZHVsZSBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0fG9iamVjdFtdPn0gVGhlIGNvbnRlbnQgb2YgdGhlIHJlc3VsdGluZyBkaWN0aW9uYXJ5IGRlcGVuZHNcbiAqIG9uIHRoZSBhY3R1YWwgYG1vZGVgIGFuZCBgb3B0aW9uc2AgdmFsdWVzLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiAqIGBAYXBwaXVtL3N1cHBvcnRgIG1vZHVsZSBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHJlcXVpcmVkIE9wZW5DViBtb2R1bGVzIGFyZSBub3QgaW5zdGFsbGVkIG9yXG4gKiBpZiBgbW9kZWAgdmFsdWUgaXMgaW5jb3JyZWN0IG9yIGlmIHRoZXJlIHdhcyBhbiB1bmV4cGVjdGVkIGlzc3VlIHdoaWxlXG4gKiBtYXRjaGluZyB0aGUgaW1hZ2VzLlxuICovXG5hc3luYyBmdW5jdGlvbiBjb21wYXJlSW1hZ2VzKG1vZGUsIGZpcnN0SW1hZ2UsIHNlY29uZEltYWdlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaW1nMSA9IEJ1ZmZlci5mcm9tKGZpcnN0SW1hZ2UsICdiYXNlNjQnKTtcbiAgY29uc3QgaW1nMiA9IEJ1ZmZlci5mcm9tKHNlY29uZEltYWdlLCAnYmFzZTY0Jyk7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBzd2l0Y2ggKF8udG9Mb3dlcihtb2RlKSkge1xuICAgIGNhc2UgTUFUQ0hfRkVBVFVSRVNfTU9ERS50b0xvd2VyQ2FzZSgpOlxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgZ2V0SW1hZ2VzTWF0Y2hlcyhpbWcxLCBpbWcyLCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBtaWdodCB0aHJvdyBpZiBubyBtYXRjaGVzXG4gICAgICAgIHJlc3VsdCA9IHtjb3VudDogMH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEdFVF9TSU1JTEFSSVRZX01PREUudG9Mb3dlckNhc2UoKTpcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGdldEltYWdlc1NpbWlsYXJpdHkoaW1nMSwgaW1nMiwgb3B0aW9ucyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE1BVENIX1RFTVBMQVRFX01PREUudG9Mb3dlckNhc2UoKTpcbiAgICAgIC8vIGZpcnN0SW1hZ2UvaW1nMSBpcyB0aGUgZnVsbCBpbWFnZSBhbmQgc2Vjb25kSW1hZ2UvaW1nMiBpcyB0aGUgcGFydGlhbCBvbmVcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGdldEltYWdlT2NjdXJyZW5jZShpbWcxLCBpbWcyLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubXVsdGlwbGUubWFwKGNvbnZlcnRWaXN1YWxpemF0aW9uVG9CYXNlNjQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGAnJHttb2RlfScgaW1hZ2VzIGNvbXBhcmlzb24gbW9kZSBpcyB1bmtub3duLiBgICtcbiAgICAgICAgICBgT25seSAke0pTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgIE1BVENIX0ZFQVRVUkVTX01PREUsXG4gICAgICAgICAgICBHRVRfU0lNSUxBUklUWV9NT0RFLFxuICAgICAgICAgICAgTUFUQ0hfVEVNUExBVEVfTU9ERSxcbiAgICAgICAgICBdKX0gbW9kZXMgYXJlIHN1cHBvcnRlZC5gXG4gICAgICApO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VmlzdWFsaXphdGlvblRvQmFzZTY0KHJlc3VsdCk7XG59XG5cbi8qKlxuICogYmFzZTY0IGVuY29kZXMgdGhlIHZpc3VhbGl6YXRpb24gcGFydCBvZiB0aGUgcmVzdWx0XG4gKiAoaWYgbmVjZXNzYXJ5KVxuICpcbiAqIEBwYXJhbSB7T2NjdXJyZW5jZVJlc3VsdH0gZWxlbWVudCAtIG9jY3VycmVuY2UgcmVzdWx0XG4gKlxuICoqL1xuZnVuY3Rpb24gY29udmVydFZpc3VhbGl6YXRpb25Ub0Jhc2U2NChlbGVtZW50KSB7XG4gIGlmICghXy5pc0VtcHR5KGVsZW1lbnQudmlzdWFsaXphdGlvbikpIHtcbiAgICBlbGVtZW50LnZpc3VhbGl6YXRpb24gPSBlbGVtZW50LnZpc3VhbGl6YXRpb24udG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7XG4gIGNvbXBhcmVJbWFnZXMsXG4gIERFRkFVTFRfTUFUQ0hfVEhSRVNIT0xELFxuICBNQVRDSF9URU1QTEFURV9NT0RFLFxuICBNQVRDSF9GRUFUVVJFU19NT0RFLFxuICBHRVRfU0lNSUxBUklUWV9NT0RFLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAYXBwaXVtL29wZW5jdicpLk9jY3VycmVuY2VSZXN1bHR9IE9jY3VycmVuY2VSZXN1bHRcbiAqL1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxtQkFBbUIsR0FBRyxlQUE1Qjs7QUFDQSxNQUFNQyxtQkFBbUIsR0FBRyxlQUE1Qjs7QUFDQSxNQUFNQyxtQkFBbUIsR0FBRyxlQUE1Qjs7QUFFQSxNQUFNQyx1QkFBdUIsR0FBRyxHQUFoQzs7O0FBdUJBLGVBQWVDLGFBQWYsQ0FBNkJDLElBQTdCLEVBQW1DQyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNERDLE9BQU8sR0FBRyxFQUF0RSxFQUEwRTtFQUN4RSxNQUFNQyxJQUFJLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZTCxVQUFaLEVBQXdCLFFBQXhCLENBQWI7RUFDQSxNQUFNTSxJQUFJLEdBQUdGLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZSixXQUFaLEVBQXlCLFFBQXpCLENBQWI7RUFDQSxJQUFJTSxNQUFNLEdBQUcsSUFBYjs7RUFDQSxRQUFRQyxlQUFBLENBQUVDLE9BQUYsQ0FBVVYsSUFBVixDQUFSO0lBQ0UsS0FBS0wsbUJBQW1CLENBQUNnQixXQUFwQixFQUFMO01BQ0UsSUFBSTtRQUNGSCxNQUFNLEdBQUcsTUFBTSxJQUFBSSx3QkFBQSxFQUFpQlIsSUFBakIsRUFBdUJHLElBQXZCLEVBQTZCSixPQUE3QixDQUFmO01BQ0QsQ0FGRCxDQUVFLE9BQU9VLEdBQVAsRUFBWTtRQUVaTCxNQUFNLEdBQUc7VUFBQ00sS0FBSyxFQUFFO1FBQVIsQ0FBVDtNQUNEOztNQUNEOztJQUNGLEtBQUtsQixtQkFBbUIsQ0FBQ2UsV0FBcEIsRUFBTDtNQUNFSCxNQUFNLEdBQUcsTUFBTSxJQUFBTywyQkFBQSxFQUFvQlgsSUFBcEIsRUFBMEJHLElBQTFCLEVBQWdDSixPQUFoQyxDQUFmO01BQ0E7O0lBQ0YsS0FBS04sbUJBQW1CLENBQUNjLFdBQXBCLEVBQUw7TUFFRUgsTUFBTSxHQUFHLE1BQU0sSUFBQVEsMEJBQUEsRUFBbUJaLElBQW5CLEVBQXlCRyxJQUF6QixFQUErQkosT0FBL0IsQ0FBZjs7TUFDQSxJQUFJQSxPQUFPLENBQUNjLFFBQVosRUFBc0I7UUFDcEIsT0FBT1QsTUFBTSxDQUFDUyxRQUFQLENBQWdCQyxHQUFoQixDQUFvQkMsNEJBQXBCLENBQVA7TUFDRDs7TUFDRDs7SUFDRjtNQUNFLE1BQU0sSUFBSUMsY0FBQSxDQUFPQyxvQkFBWCxDQUNILElBQUdyQixJQUFLLHVDQUFULEdBQ0csUUFBT3NCLElBQUksQ0FBQ0MsU0FBTCxDQUFlLENBQ3JCNUIsbUJBRHFCLEVBRXJCQyxtQkFGcUIsRUFHckJDLG1CQUhxQixDQUFmLENBSUwsdUJBTkQsQ0FBTjtFQXBCSjs7RUE2QkEsT0FBT3NCLDRCQUE0QixDQUFDWCxNQUFELENBQW5DO0FBQ0Q7O0FBU0QsU0FBU1csNEJBQVQsQ0FBc0NLLE9BQXRDLEVBQStDO0VBQzdDLElBQUksQ0FBQ2YsZUFBQSxDQUFFZ0IsT0FBRixDQUFVRCxPQUFPLENBQUNFLGFBQWxCLENBQUwsRUFBdUM7SUFDckNGLE9BQU8sQ0FBQ0UsYUFBUixHQUF3QkYsT0FBTyxDQUFDRSxhQUFSLENBQXNCQyxRQUF0QixDQUErQixRQUEvQixDQUF4QjtFQUNEOztFQUVELE9BQU9ILE9BQVA7QUFDRCJ9