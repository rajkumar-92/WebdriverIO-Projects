"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Workbench = void 0;
const TitleBar_1 = require("../menu/TitleBar");
const SideBarView_1 = require("../sidebar/SideBarView");
const ActivityBar_1 = require("../activityBar/ActivityBar");
const StatusBar_1 = require("../statusBar/StatusBar");
const EditorView_1 = require("../editor/EditorView");
const BottomBarPanel_1 = require("../bottomBar/BottomBarPanel");
const Notification_1 = require("./Notification");
const Input_1 = require("./Input");
const SettingsEditor_1 = require("../editor/SettingsEditor");
const WebView_1 = require("./WebView");
const utils_1 = require("../utils");
const _1_73_0_1 = require("../../locators/1.73.0");
/**
 * Page object representing the custom VSCode title bar
 *
 * @category Workbench
 */
let Workbench = class Workbench extends utils_1.BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'Workbench';
    }
    /**
     * Get a title bar handle
     */
    getTitleBar() {
        return new TitleBar_1.TitleBar(this.locatorMap);
    }
    /**
     * Get a side bar handle
     */
    getSideBar() {
        return new SideBarView_1.SideBarView(this.locatorMap);
    }
    /**
     * Get an activity bar handle
     */
    getActivityBar() {
        return new ActivityBar_1.ActivityBar(this.locatorMap);
    }
    /**
     * Get a status bar handle
     */
    getStatusBar() {
        return new StatusBar_1.StatusBar(this.locatorMap);
    }
    /**
     * Get a bottom bar handle
     */
    getBottomBar() {
        return new BottomBarPanel_1.BottomBarPanel(this.locatorMap);
    }
    /**
     * Get a handle for the editor view
     */
    getEditorView() {
        return new EditorView_1.EditorView(this.locatorMap);
    }
    /**
     * Get all available webviews
     */
    getAllWebviews() {
        return WebView_1.WebView.getAllWebViews(this._locators);
    }
    /**
     * Get webview by title
     */
    async getWebviewByTitle(title) {
        const webviews = await this.getAllWebviews();
        if (webviews.length === 0) {
            throw new Error('No webviews found');
        }
        const foundTitles = [];
        const getTitle = () => document.title;
        for (const webview of webviews) {
            /**
             * jump into webview
             */
            await webview.open();
            /**
             * get the title of webview
             */
            const webviewTitle = await browser.execute(getTitle);
            foundTitles.push(webviewTitle);
            /**
             * jump out of webview
             */
            await webview.close();
            if (webviewTitle.match(title)) {
                return webview;
            }
        }
        throw new Error(`Couldn't find webview with title "${title}", `
            + `the following webview titles were found: "${foundTitles.join('", "')}"`);
    }
    /**
     * Get all standalone notifications (notifications outside the notifications center)
     * @returns Promise resolving to array of Notification objects
     */
    async getNotifications() {
        const notifications = [];
        const containers = await this.notificationContainer$$;
        if (containers.length === 0) {
            return [];
        }
        for (const container of containers) {
            const elements = await container.$$(this.locators.notificationItem);
            for (const element of elements) {
                notifications.push(await new Notification_1.StandaloneNotification(this.locatorMap, 
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                element).wait());
            }
        }
        return notifications;
    }
    /**
     * Verifies if any notifications are shown
     * @returns true if workbench has notifications, false otherwise
     */
    hasNotifications() {
        return this.notificationContainer$.isExisting();
    }
    /**
     * Opens the notifications center
     * @returns Promise resolving to NotificationsCenter object
     */
    openNotificationsCenter() {
        const statusBar = new StatusBar_1.StatusBar(this.locatorMap);
        return statusBar.openNotificationsCenter();
    }
    /**
     * Opens the settings editor
     *
     * @returns promise that resolves to a SettingsEditor instance
     */
    async openSettings() {
        await this.executeCommand('Preferences: Open User Settings');
        await new EditorView_1.EditorView(this.locatorMap).openEditor('Settings');
        await this.elem.$(this.locatorMap.Editor.elem).waitForExist();
        await (0, utils_1.sleep)(500);
        return new SettingsEditor_1.SettingsEditor(this.locatorMap);
    }
    /**
     * Open the VS Code command line prompt
     * @returns Promise resolving to InputBox (vscode 1.44+) or QuickOpenBox (vscode up to 1.43) object
     */
    async openCommandPrompt() {
        const editorView = await new EditorView_1.EditorView(this.locatorMap).wait();
        const webview = await editorView.webView$$;
        if (webview.length > 0) {
            const tab = await editorView.getActiveTab();
            if (tab) {
                await tab.elem.addValue(['F1']);
                const inputBox = new Input_1.InputBox(this.locatorMap).wait();
                return inputBox;
            }
        }
        await browser.keys(['F1']);
        if ((await browser.getVSCodeChannel() === 'vscode' && await browser.getVSCodeVersion() >= '1.44.0')
            || await browser.getVSCodeVersion() === 'insiders') {
            return new Input_1.InputBox(this.locatorMap).wait();
        }
        return new Input_1.QuickOpenBox(this.locatorMap).wait();
    }
    /**
     * Open the command prompt, type in a command, find the command using a fuzzy match, and execute
     * @param command text of the command to be executed
     * @returns Promise resolving to InputBox (vscode 1.44+) or QuickOpenBox (vscode up to 1.43) object
     * when the command prompt is confirmed
     */
    async executeCommand(command) {
        const prompt = await this.openCommandPrompt();
        await prompt.setText(`>${command}`);
        await prompt.confirm();
        return prompt;
    }
    /**
     * Open the command prompt, type in a command, find the command from the quick pick list, and execute
     * @param command text of the command to be executed
     * @returns Promise resolving to InputBox (vscode 1.44+) or QuickOpenBox (vscode up to 1.43) object
     * when the command prompt is confirmed
     */
    async executeQuickPick(command) {
        const prompt = await this.openCommandPrompt();
        await prompt.setText(`>${command}`);
        const quickPicks = await prompt.getQuickPicks();
        for (const quickPick of quickPicks) {
            const label = await quickPick.getLabel();
            if (label === command) {
                await quickPick.select();
                return prompt;
            }
        }
        throw new Error('Command not found');
    }
};
Workbench = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.Workbench)
], Workbench);
exports.Workbench = Workbench;
//# sourceMappingURL=Workbench.js.map