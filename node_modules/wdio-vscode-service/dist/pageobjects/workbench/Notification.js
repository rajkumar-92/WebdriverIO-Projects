"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CenterNotification = exports.StandaloneNotification = exports.Notification = exports.NotificationType = void 0;
const utils_1 = require("../utils");
const _1_73_0_1 = require("../../locators/1.73.0");
/**
 * Available types of notifications
 * @hidden
 */
var NotificationType;
(function (NotificationType) {
    NotificationType["Info"] = "info";
    NotificationType["Warning"] = "warning";
    NotificationType["Error"] = "error";
    NotificationType["Any"] = "any";
})(NotificationType = exports.NotificationType || (exports.NotificationType = {}));
/**
 * Notification button
 *
 * @category Workbench
 */
class NotificationButton extends utils_1.BasePage {
    constructor(locators, title) {
        super(locators, locators.Notification.buttonConstructor(title));
        /**
         * @private
         */
        this.locatorKey = 'Notification';
        this.title = title;
    }
    getTitle() {
        return this.title;
    }
}
/**
 * Abstract element representing a notification
 *
 * @category Workbench
 */
class Notification extends utils_1.BasePage {
    /**
     * Get the message of the notification
     * @returns Promise resolving to notification message
     */
    getMessage() {
        return this.message$.getText();
    }
    /**
     * Get the type of the notification
     * @returns Promise resolving to NotificationType
     */
    async getType() {
        const iconType = await this.icon$.getAttribute('class');
        if (iconType.indexOf('icon-info') > -1) {
            return NotificationType.Info;
        }
        if (iconType.indexOf('icon-warning') > -1) {
            return NotificationType.Warning;
        }
        return NotificationType.Error;
    }
    /**
     * Get the source of the notification as text
     * @returns Promise resolving to notification source
     */
    async getSource() {
        await this.expand();
        return this.source$.getAttribute('title');
    }
    /**
     * Find whether the notification has an active progress bar
     * @returns Promise resolving to true/false
     */
    async hasProgress() {
        const klass = await this.progress$.getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    /**
     * Dismiss the notification
     * @returns Promise resolving when notification is dismissed
     */
    async dismiss() {
        const btn = await this.dismiss$;
        /**
         * make button interactable given they only contain
         * text on hover
         */
        await browser.execute((btnSection) => { btnSection.style.display = 'block'; }, await this.btnSection$);
        await btn.click();
    }
    /**
     * Get the action buttons of the notification as an array
     * of NotificationButton objects
     * @returns Promise resolving to array of NotificationButton objects
     */
    async getActions() {
        const buttons = [];
        const elements = await this.actions$
            .$$(this.locators.action);
        for (const button of elements) {
            buttons.push(await new NotificationButton(this.locatorMap, await button.getAttribute(this.locators.actionLabel)).wait());
        }
        return buttons;
    }
    /**
     * Click on an action button with the given title
     * @param title title of the action/button
     * @returns Promise resolving when the select button is pressed
     */
    async takeAction(title) {
        await new NotificationButton(this.locatorMap, title).elem.click();
    }
    /**
     * Expand the notification if possible
     */
    async expand() {
        await this.elem.moveTo();
        const exp = await this.expand$$;
        if (exp[0]) {
            await exp[0].click();
        }
    }
}
exports.Notification = Notification;
/**
 * Notification displayed on its own in the notifications-toasts container
 *
 * @category Workbench
 */
let StandaloneNotification = class StandaloneNotification extends Notification {
    constructor(locators, notification) {
        super(locators, notification, locators.Notification.standaloneContainer);
        /**
         * @private
         */
        this.locatorKey = 'Notification';
    }
};
StandaloneNotification = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.Notification)
], StandaloneNotification);
exports.StandaloneNotification = StandaloneNotification;
/**
 * Notification displayed within the notifications center
 *
 * @category Workbench
 */
let CenterNotification = class CenterNotification extends Notification {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'Notification';
    }
};
CenterNotification = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.Notification)
], CenterNotification);
exports.CenterNotification = CenterNotification;
//# sourceMappingURL=Notification.js.map