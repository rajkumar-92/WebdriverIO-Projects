{"version":3,"file":"WebView.js","sourceRoot":"","sources":["../../../src/pageobjects/workbench/WebView.ts"],"names":[],"mappings":";;;;;;;;;;AACA,oCAAkE;AAClE,mDAAkE;AAIlE,gEAAgE;AAEzD,IAAM,OAAO,eAAb,MAAM,OAAQ,SAAQ,gBAAgC;IAAtD;;QACH;;WAEG;QACI,eAAU,GAAG,SAAkB,CAAA;IAkD1C,CAAC;IAhDG,IAAI,WAAW;QACX,OAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,WAAqB,CAAC,CAAA;IAC1D,CAAC;IAED;;;;;;OAMG;IACI,KAAK,CAAC,IAAI;QACb,MAAM,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QACtC,MAAM,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,CAAC,YAAY,EAAE,CAAA;QAC7C,MAAM,OAAO,CAAC,aAAa,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,CAAA;IACvD,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,KAAK;QACd,MAAM,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAA;QACjC,MAAM,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAA;IACrC,CAAC;IAED;;;;OAIG;IACH,MAAM,CAAC,KAAK,CAAC,cAAc,CAAE,QAA0B;QACnD,IAAI;YACA;;eAEG;YACH,MAAM,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAoB,CAAC,CAAC,YAAY,CAAC;gBAChE,OAAO,EAAE,IAAI;gBACb,UAAU,EAAE,mBAAmB;aAClC,CAAC,CAAA;SACL;QAAC,OAAO,GAAQ,EAAE;YACf,OAAO,EAAE,CAAA;SACZ;QAED,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAoB,CAAC,CAAA;QACtE,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CACrB,IAAI,SAAO,CAAC,QAAQ,EAAE,CAAwD,CAAC,CAClF,CAAC,CAAA;IACN,CAAC;CACJ,CAAA;AAtDY,OAAO;IADnB,IAAA,qBAAa,EAAC,iBAAe,CAAC;GAClB,OAAO,CAsDnB;AAtDY,0BAAO","sourcesContent":["import { ChainablePromiseElement } from 'webdriverio'\nimport { BasePage, PageDecorator, IPageDecorator } from '../utils'\nimport { WebView as WebViewLocators } from '../../locators/1.73.0'\nimport type { VSCodeLocatorMap } from '../utils'\n\nexport interface WebView extends IPageDecorator<typeof WebViewLocators> { }\n// @ts-expect-error `PageDecorator` doesn't allow static methods\n@PageDecorator(WebViewLocators)\nexport class WebView extends BasePage<typeof WebViewLocators> {\n    /**\n     * @private locator key to identify locator map (see locators.ts)\n     */\n    public locatorKey = 'WebView' as const\n\n    get activeFrame () {\n        return $(this._locators.WebView.activeFrame as string)\n    }\n\n    /**\n     * Switch WebDriver context to given webview so subsequent element\n     * calls are targeting elements within the webview.\n     *\n     * __Note:__ ensure to call `webview.close()` to leave the webview\n     * context before using other page objects.\n     */\n    public async open () {\n        await browser.switchToFrame(this.elem)\n        await (await this.activeFrame).waitForExist()\n        await browser.switchToFrame(await this.activeFrame)\n    }\n\n    /**\n     * Switch from the webview context back to the VSCode context.\n     */\n    public async close () {\n        await browser.switchToFrame(null)\n        await browser.switchToFrame(null)\n    }\n\n    /**\n     * Get all available WebViews (including the once in the sidebar or from the editor)\n     * @param locators locator map\n     * @returns a list of webview objects\n     */\n    static async getAllWebViews (locators: VSCodeLocatorMap) {\n        try {\n            /**\n             * webviews might not be immediatelly available when VS Code boots up\n             */\n            await browser.$(locators.WebView.outerFrame as string).waitForExist({\n                timeout: 5000,\n                timeoutMsg: 'no webviews found'\n            })\n        } catch (err: any) {\n            return []\n        }\n\n        const frames = await browser.$$(locators.WebView.outerFrame as string)\n        return frames.map((f) => (\n            new WebView(locators, f as any as ChainablePromiseElement<WebdriverIO.Element>)\n        ))\n    }\n}\n"]}