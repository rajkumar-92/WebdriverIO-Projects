"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickOpenBox = exports.InputBox = exports.QuickPickItem = exports.Input = void 0;
const clipboardy_1 = __importDefault(require("clipboardy"));
const utils_1 = require("../utils");
const _1_73_0_1 = require("../../locators/1.73.0");
const constants_1 = require("../../constants");
const HOME_KEY = process.platform === 'win32'
    ? 'a'
    : 'Home';
/**
 * Abstract page object for input fields
 *
 * @category Workbench
 */
class Input extends utils_1.BasePage {
    /**
     * Get current text of the input field
     * @returns Promise resolving to text of the input field
     */
    async getText() {
        const input = await this.inputBox$.$(this.locators.input);
        return input.getAttribute('value');
    }
    /**
     * Set (by selecting all and typing) text in the input field
     * @param text text to set into the input field
     * @returns Promise resolving when the text is typed in
     */
    async setText(text) {
        const input = await this.inputBox$.$(this.locators.input);
        await this.clear();
        await (0, utils_1.sleep)(200);
        if ((await this.getText())?.length > 0) {
            await input.addValue(['End', 'Shift', HOME_KEY]);
        }
        await input.addValue(text);
        // fallback to clipboard if the text gets malformed
        const currentText = await this.getText();
        if (currentText !== text) {
            await clipboardy_1.default.write(text);
            if (currentText?.length) {
                const backSpaces = new Array(currentText.length).fill('Backspace');
                await input.addValue(backSpaces);
            }
            await clipboardy_1.default.write('');
        }
    }
    /**
     * Get the placeholder text for the input field
     * @returns Promise resolving to input placeholder
     */
    async getPlaceHolder() {
        return this.inputBox$.$(this.locators.input).getAttribute('placeholder');
    }
    /**
     * Confirm the input field by pressing Enter
     * @returns Promise resolving when the input is confirmed
     */
    async confirm() {
        const input = this.inputBox$.$(this.locators.input);
        await input.click();
        await input.addValue(['Enter']);
    }
    /**
     * Cancel the input field by pressing Escape
     * @returns Promise resolving when the input is cancelled
     */
    async cancel() {
        await this.inputBox$.$(this.locators.input).addValue(['Escape']);
    }
    /**
     * Clear the inpur field
     * @returns Promise resolving when the field is cleared
     */
    async clear() {
        const input = await this.inputBox$.$(this.locators.input);
        // VS Code 1.40 breaks the default clear method, use select all + back space instead
        await input.addValue(['End']);
        await input.addValue([constants_1.CMD_KEY, HOME_KEY]);
        await input.addValue(['Backspace']);
        if ((await input.getAttribute('value'))?.length > 0) {
            await input.addValue(['End']);
            await input.addValue([constants_1.CMD_KEY, HOME_KEY]);
            await input.addValue(['Backspace']);
        }
    }
    /**
     * Select (click) a quick pick option. Will scroll through the quick picks to find the item.
     * Search for the item can be done by its text, or index in the quick pick menu.
     * Note that scrolling does not affect the item's index, but it will
     * replace some items in the DOM (thus they become unreachable)
     *
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolving when the given quick pick is selected
     */
    async selectQuickPick(indexOrText) {
        const pick = await this.findQuickPick(indexOrText);
        if (pick) {
            await pick.select();
        }
        else {
            await this.resetPosition();
        }
    }
    /**
     * Select/Deselect all quick picks using the 'select all' checkbox
     * If multiple selection is disabled on the input box, no action is performed
     *
     * @param state true to select all, false to deselect all
     * @returns Promise resolving when all quick picks have been toggled to desired state
     */
    async toggleAllQuickPicks(state) {
        const checkboxes = await this.quickPickSelectAll$$;
        if (checkboxes.length < 0) {
            return;
        }
        if (!await checkboxes[0].isSelected()) {
            await checkboxes[0].click();
        }
        if (state === false) {
            await checkboxes[0].click();
        }
    }
    /**
     * Scroll through the quick picks to find an item by the name or index
     * @param indexOrText index (number) or text (string) of the item to search by
     * @returns Promise resolvnig to QuickPickItem if found, to undefined otherwise
     */
    async findQuickPick(indexOrText) {
        const input = await this.inputBox$.$(this.locators.input);
        const first = await this.quickPickPosition$$(1);
        if (first.length < 1) {
            await this.resetPosition();
        }
        let endReached = false;
        while (!endReached) {
            const picks = await this.getQuickPicks();
            for (const pick of picks) {
                const lastRow = await this.elem.$$(this.locatorMap.DefaultTreeSection.lastRow);
                if (lastRow.length > 0) {
                    endReached = true;
                }
                else if (await pick.elem.getAttribute('aria-posinset') === await pick.elem.getAttribute('aria-setsize')) {
                    endReached = true;
                }
                if (typeof indexOrText === 'string') {
                    const text = await pick.getLabel();
                    if (text.indexOf(indexOrText) > -1) {
                        return pick;
                    }
                }
                else if (indexOrText === pick.getIndex()) {
                    return pick;
                }
            }
            if (!endReached) {
                await input.addValue(['PageDown']);
            }
        }
        return undefined;
    }
    /**
     * Retrieve the title of an input box if it has one
     * @returns Promise resolving to title if it exists, to undefined otherwise
     */
    async getTitle() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            return (await titleBar[0].$(this.locators.title)).getText();
        }
        return undefined;
    }
    /**
     * Click on the back button if it exists
     * @returns Promise resolving to true if a button was clicked, to false otherwise
     */
    async back() {
        const titleBar = await this.titleBar$$;
        if (titleBar.length > 0 && await titleBar[0].isDisplayed()) {
            const backBtn = await titleBar[0].$$(this.locators.backButton);
            if (backBtn.length > 0 && await backBtn[0].isEnabled()) {
                await backBtn[0].click();
                return true;
            }
        }
        return false;
    }
    async resetPosition() {
        const text = await this.getText();
        await this.clear();
        await this.setText(text);
    }
}
exports.Input = Input;
/**
 * Page object representing a quick pick option in the input box
 *
 * @category Workbench
 */
let QuickPickItem = class QuickPickItem extends utils_1.BasePage {
    constructor(locators, index, inputField) {
        const quickPickPositionFn = locators.Input.quickPickPosition;
        const quickPickIndexFn = locators.Input.quickPickIndex;
        const baseParam = inputField instanceof QuickOpenBox
            ? quickPickPositionFn(index)
            : quickPickIndexFn(index);
        super(locators, baseParam);
        /**
         * @private
         */
        this.locatorKey = 'Input';
        this.index = index;
        this.input = inputField;
    }
    /**
     * Get the label of the quick pick item
     */
    async getLabel() {
        return this.quickPickLabel$.getText();
    }
    /**
     * Get the description of the quick pick item
     */
    async getDescription() {
        try {
            return await this.quickPickDescription$.getText();
        }
        catch (err) {
            return undefined;
        }
    }
    /**
     * Get the index of the quick pick item
     */
    getIndex() {
        return this.index;
    }
    /**
     * Select (click) the quick pick item
     * @returns Promise resolving when the item has been clicked
     */
    async select() {
        await this.elem.click();
    }
};
QuickPickItem = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.Input)
], QuickPickItem);
exports.QuickPickItem = QuickPickItem;
/**
 * Plain input box variation of the input page object
 *
 * @category Workbench
 */
let InputBox = class InputBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'InputBox'];
    }
    /**
     * Get the message below the input field
     */
    async getMessage() {
        return this.message$.getText();
    }
    async hasProgress() {
        const klass = await this.progress$.getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const elements = await this.quickList$
            .$(this.locators.rows)
            .$$(this.locators.row);
        for (const element of elements) {
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, parseInt(await element.getAttribute('data-index'), 10), this).wait());
            }
        }
        return picks;
    }
    /**
     * Find whether the input is showing an error
     * @returns Promise resolving to notification message
     */
    async hasError() {
        const klass = await this.inputBox$.getAttribute('class');
        return klass.indexOf('error') > -1;
    }
    /**
     * Check if the input field is masked (input type password)
     * @returns Promise resolving to notification message
     */
    async isPassword() {
        return (await this.input$.getAttribute('type')) === 'password';
    }
};
InputBox = __decorate([
    (0, utils_1.PageDecorator)({ ..._1_73_0_1.Input, ..._1_73_0_1.InputBox })
], InputBox);
exports.InputBox = InputBox;
/**
 * @deprecated as of VS Code 1.44.0, quick open box has been replaced with input box
 * The quick open box variation of the input
 *
 * @category Workbench
 */
let QuickOpenBox = class QuickOpenBox extends Input {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['Input', 'QuickOpenBox'];
    }
    async hasProgress() {
        const klass = await this.progress$
            .getAttribute('class');
        return klass.indexOf('done') < 0;
    }
    async getQuickPicks() {
        const picks = [];
        const tree = await browser.$(this.locators.quickList);
        await tree.waitForExist({ timeout: 1000 });
        const elements = await tree.$$(this.locators.row);
        for (const element of elements) {
            const index = parseInt(await element.getAttribute('aria-posinset'), 10);
            if (await element.isDisplayed()) {
                picks.push(await new QuickPickItem(this.locatorMap, index, this).wait());
            }
        }
        return picks;
    }
};
QuickOpenBox = __decorate([
    (0, utils_1.PageDecorator)({ ..._1_73_0_1.Input, ..._1_73_0_1.QuickOpenBox })
], QuickOpenBox);
exports.QuickOpenBox = QuickOpenBox;
//# sourceMappingURL=Input.js.map