{"version":3,"file":"EditorView.js","sourceRoot":"","sources":["../../../src/pageobjects/editor/EditorView.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ChainablePromiseElement } from 'webdriverio'\n\nimport { TextEditor, DiffEditor, SettingsEditor } from '..'\nimport {\n    PageDecorator, IPageDecorator, BasePage, ElementWithContextMenu, VSCodeLocatorMap\n} from '../utils'\nimport {\n    EditorView as EditorViewLocators,\n    Editor as EditorLocatorsObj\n} from '../../locators/1.73.0'\n\nexport interface EditorView extends IPageDecorator<typeof EditorViewLocators> {}\n/**\n * View handling the open editors\n *\n * @category Editor\n */\n@PageDecorator(EditorViewLocators)\nexport class EditorView extends BasePage<typeof EditorViewLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'EditorView' as const\n\n    /**\n     * Switch to an editor tab with the given title\n     * @param title title of the tab\n     * @param groupIndex zero based index for the editor group (0 for the left most group)\n     * @returns Promise resolving to Editor object\n     */\n    async openEditor (title: string, groupIndex = 0) {\n        const group = await this.getEditorGroup(groupIndex)\n        return group.openEditor(title)\n    }\n\n    /**\n     * Close an editor tab with the given title\n     * @param title title of the tab\n     * @param groupIndex zero based index for the editor group (0 for the left most group)\n     * @returns Promise resolving when the tab's close button is pressed\n     */\n    async closeEditor (title: string, groupIndex = 0): Promise<void> {\n        const group = await this.getEditorGroup(groupIndex)\n        return group.closeEditor(title)\n    }\n\n    /**\n     * Close all open editor tabs\n     * @param groupIndex optional index to specify an editor group\n     * @returns Promise resolving once all tabs have had their close button pressed\n     */\n    async closeAllEditors (groupIndex?: number): Promise<void> {\n        let groups = await this.getEditorGroups()\n        if (groupIndex !== undefined) {\n            await groups[0].closeAllEditors()\n            return\n        }\n\n        while (groups.length > 0 && (await groups[0].getOpenEditorTitles()).length > 0) {\n            await groups[0].closeAllEditors()\n            groups = await this.getEditorGroups()\n        }\n    }\n\n    /**\n     * Retrieve all open editor tab titles in an array\n     * @param groupIndex optional index to specify an editor group, if left empty will search all groups\n     * @returns Promise resolving to array of editor titles\n     */\n    async getOpenEditorTitles (groupIndex?: number): Promise<string[]> {\n        const groups = await this.getEditorGroups()\n        if (groupIndex !== undefined) {\n            return groups[groupIndex].getOpenEditorTitles()\n        }\n        const titles: string[] = []\n        for (const group of groups) {\n            titles.push(...(await group.getOpenEditorTitles()))\n        }\n        return titles\n    }\n\n    /**\n     * Retrieve an editor tab from a given group by title\n     * @param title title of the tab\n     * @param groupIndex zero based index of the editor group, default 0 (leftmost one)\n     * @returns promise resolving to EditorTab object\n     */\n    async getTabByTitle (title: string, groupIndex = 0): Promise<EditorTab> {\n        const group = await this.getEditorGroup(groupIndex)\n        return group.getTabByTitle(title)\n    }\n\n    /**\n     * Retrieve all open editor tabs\n     * @param groupIndex index of group to search for tabs, if left undefined, all groups are searched\n     * @returns promise resolving to EditorTab list\n     */\n    async getOpenTabs (groupIndex?: number): Promise<EditorTab[]> {\n        const groups = await this.getEditorGroups()\n        if (groupIndex !== undefined) {\n            return groups[groupIndex].getOpenTabs()\n        }\n        const tabs: EditorTab[] = []\n        for (const group of groups) {\n            tabs.push(...(await group.getOpenTabs()))\n        }\n        return tabs\n    }\n\n    /**\n     * Retrieve the active editor tab\n     * @returns promise resolving to EditorTab object, undefined if no tab is active\n     */\n    async getActiveTab (): Promise<EditorTab | undefined> {\n        const tabs = await this.getOpenTabs()\n        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')))\n        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1)\n\n        if (index > -1) {\n            return tabs[index]\n        }\n        return undefined\n    }\n\n    /**\n     * Retrieve all editor groups in a list, sorted left to right\n     * @returns promise resolving to an array of EditorGroup objects\n     */\n    async getEditorGroups (): Promise<EditorGroup[]> {\n        const elements = await this.editorGroup$$\n        const groups = await Promise.all(\n            elements.map(async (element) => (\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                new EditorGroup(this.locatorMap, element as any, this).wait()\n            ))\n        )\n\n        // sort the groups by x coordinates, so the leftmost is always at index 0\n        for (let i = 0; i < groups.length - 1; i += 1) {\n            for (let j = 0; j < groups.length - i - 1; j += 1) {\n                if ((await groups[j].elem.getLocation('x')) > (await groups[j + 1].elem.getLocation('x'))) {\n                    const temp = groups[j]\n                    groups[j] = groups[j + 1]\n                    groups[j + 1] = temp\n                }\n            }\n        }\n        return groups\n    }\n\n    /**\n     * Retrieve an editor group with a given index (counting from left to right)\n     * @param index zero based index of the editor group (leftmost group has index 0)\n     * @returns promise resolving to an EditorGroup object\n     */\n    async getEditorGroup (index: number): Promise<EditorGroup> {\n        return (await this.getEditorGroups())[index]\n    }\n\n    /**\n     * Get editor actions of a select editor group\n     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0\n     * @returns promise resolving to list of WebElement objects\n     */\n    async getActions (groupIndex = 0) {\n        const group = await this.getEditorGroup(groupIndex)\n        return group.getActions()\n    }\n\n    /**\n     * Get editor action of a select editor group, search by title\n     * @param groupIndex zero based index of the editor group (leftmost group has index 0), default 0\n     * @returns promise resolving to WebElement object if found, undefined otherwise\n     */\n    async getAction (title: string, groupIndex = 0) {\n        const group = await this.getEditorGroup(groupIndex)\n        return group.getAction(title)\n    }\n}\n\nexport interface EditorGroup extends IPageDecorator<typeof EditorViewLocators> {}\n/**\n * Page object representing an editor group\n *\n * @category Editor\n */\n@PageDecorator(EditorViewLocators)\nexport class EditorGroup extends BasePage<typeof EditorViewLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'EditorView' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element: ChainablePromiseElement<WebdriverIO.Element>,\n        public view = new EditorView(locators)\n    ) {\n        super(locators, element)\n    }\n\n    /**\n     * Switch to an editor tab with the given title\n     * @param title title of the tab\n     * @returns Promise resolving to Editor object\n     */\n    async openEditor (title: string): Promise<SettingsEditor | DiffEditor | TextEditor> {\n        const tab = await this.getTabByTitle(title)\n        await tab.select()\n\n        if (await this.settingsEditor$.isExisting()) {\n            return new SettingsEditor(\n                this.locatorMap,\n                this\n            ).wait()\n        }\n\n        if (await this.diffEditor$.isExisting()) {\n            return new DiffEditor(\n                this.locatorMap,\n                this.locatorMap.Editor.elem as string,\n                this\n            ).wait()\n        }\n\n        return new TextEditor(\n            this.locatorMap,\n            this.locatorMap.Editor.elem as string,\n            this\n        ).wait()\n    }\n\n    /**\n     * Close an editor tab with the given title\n     * @param title title of the tab\n     * @returns Promise resolving when the tab's close button is pressed\n     */\n    async closeEditor (title: string): Promise<void> {\n        const tab = await this.getTabByTitle(title)\n        await tab.elem.moveTo()\n        const closeButton = await tab.elem.$(this.locators.closeTab)\n        await closeButton.click()\n    }\n\n    /**\n     * Close all open editor tabs\n     * @returns Promise resolving once all tabs have had their close button pressed\n     */\n    async closeAllEditors (): Promise<void> {\n        let titles = await this.getOpenEditorTitles()\n        while (titles.length > 0) {\n            await this.closeEditor(titles[0])\n            try {\n                // check if the group still exists\n                await this.elem.getTagName()\n            } catch (err) {\n                break\n            }\n            titles = await this.getOpenEditorTitles()\n        }\n    }\n\n    /**\n     * Retrieve all open editor tab titles in an array\n     * @returns Promise resolving to array of editor titles\n     */\n    async getOpenEditorTitles (): Promise<string[]> {\n        const tabs = await this.tab$$\n        const titles = []\n        for (const tab of tabs) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            const title = await new EditorTab(this.locatorMap, tab as any, this.view).getTitle()\n            titles.push(title)\n        }\n        return titles\n    }\n\n    /**\n     * Retrieve an editor tab by title\n     * @param title title of the tab\n     * @returns promise resolving to EditorTab object\n     */\n    async getTabByTitle (title: string): Promise<EditorTab> {\n        const tabs = await this.tab$$\n        const availableLabels = new Set()\n        for (const tab of tabs) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            const editorTab = new EditorTab(this.locatorMap, tab as any, this.view)\n            const label = await editorTab.getTitle()\n            availableLabels.add(label)\n            if (label === title) {\n                return editorTab\n            }\n        }\n        throw new Error(\n            `No editor with title '${title}' found, `\n            + `available editor were: ${[...availableLabels].join(', ')}`\n        )\n    }\n\n    /**\n     * Retrieve all open editor tabs\n     * @returns promise resolving to EditorTab list\n     */\n    async getOpenTabs (): Promise<EditorTab[]> {\n        const tabs = await this.tab$$\n        return Promise.all(\n            tabs.map(async (tab) => (\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                new EditorTab(this.locatorMap, tab as any, this.view).wait()\n            ))\n        )\n    }\n\n    /**\n     * Retrieve the active editor tab\n     * @returns promise resolving to EditorTab object, undefined if no tab is active\n     */\n    async getActiveTab (): Promise<EditorTab | undefined> {\n        const tabs = await this.getOpenTabs()\n        const klasses = await Promise.all(tabs.map(async (tab) => tab.elem.getAttribute('class')))\n        const index = klasses.findIndex((klass) => klass.indexOf('active') > -1)\n\n        if (index > -1) {\n            return tabs[index]\n        }\n        return undefined\n    }\n\n    /**\n     * Retrieve the editor action buttons as WebElements\n     * @returns promise resolving to list of WebElement objects\n     */\n    async getActions () {\n        return this.actionContainer$.$$(this.locators.actionItem)\n    }\n\n    /**\n     * Find an editor action button by title\n     * @param title title of the button\n     * @returns promise resolving to WebElement representing the button if found, undefined otherwise\n     */\n    async getAction (title: string) {\n        const actions = await this.getActions()\n        for (const item of actions) {\n            if (await item.getAttribute('title') === title) {\n                return item\n            }\n        }\n        return undefined\n    }\n}\n\nexport interface EditorTab extends IPageDecorator<typeof EditorLocatorsObj> {}\n/**\n * Page object for editor view tab\n *\n * @category Editor\n */\n@PageDecorator(EditorLocatorsObj)\nexport class EditorTab extends ElementWithContextMenu<typeof EditorLocatorsObj> {\n    /**\n     * @private\n     */\n    public locatorKey = 'Editor' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element: ChainablePromiseElement<WebdriverIO.Element>,\n        public view: EditorView\n    ) {\n        super(locators, element)\n    }\n\n    /**\n     * Get the tab title as string\n     */\n    async getTitle (): Promise<string> {\n        return this.title$.getText()\n    }\n\n    /**\n     * Select (click) the tab\n     */\n    async select (): Promise<void> {\n        await this.elem.click()\n    }\n}\n"]}