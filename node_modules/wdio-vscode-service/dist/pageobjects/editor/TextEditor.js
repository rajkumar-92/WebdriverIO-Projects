"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FindWidget = exports.CodeLens = exports.TextEditor = void 0;
const url_1 = require("url");
const clipboardy_1 = __importDefault(require("clipboardy"));
const __1 = require("..");
const StatusBar_1 = require("../statusBar/StatusBar");
const Editor_1 = require("./Editor");
const utils_1 = require("../utils");
const _1_73_0_1 = require("../../locators/1.73.0");
const constants_1 = require("../../constants");
/**
 * Page object representing the active text editor
 *
 * @category Editor
 */
let TextEditor = class TextEditor extends Editor_1.Editor {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'TextEditor';
    }
    /**
     * Find whether the active editor has unsaved changes
     * @returns Promise resolving to true/false
     */
    async isDirty() {
        const klass = await this.parent.$(this.locators.activeTab).getAttribute('class');
        return klass.indexOf('dirty') >= 0;
    }
    /**
     * Saves the active editor
     * @returns Promise resolving when ctrl+s is invoked
     */
    async save() {
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        await inputarea.addValue([constants_1.CMD_KEY, 's']);
    }
    /**
     * Open the Save as prompt
     *
     * @returns InputBox serving as a simple file dialog
     */
    async saveAs() {
        const tab = await this.getTab();
        await tab.elem.addValue([constants_1.CMD_KEY, 'Shift', 's']);
        const inputBox = browser.$(this.locatorMap.InputBox.elem);
        await inputBox.waitForExist({ timeout: 5000 });
        return new __1.InputBox(this.locatorMap, inputBox);
    }
    /**
     * Retrieve the Uri of the file opened in the active editor
     * @returns Promise resolving to editor's underlying Uri
     */
    async getFileUri() {
        const ed = await this.editorContainer$;
        return ed.getAttribute(this.locators.dataUri);
    }
    /**
     * Retrieve the path to the file opened in the active editor
     * @returns Promise resolving to editor's underlying file path
     */
    async getFilePath() {
        return (0, url_1.fileURLToPath)(await this.getFileUri());
    }
    /**
     * Open/Close the content assistant at the current position in the editor by sending the default
     * keyboard shortcut signal
     * @param open true to open, false to close
     * @returns Promise resolving to ContentAssist object when opening, void otherwise
     */
    async toggleContentAssist(open) {
        let isHidden = true;
        try {
            const assist = await this.elem.$(this.locatorMap.ContentAssist.elem);
            const klass = await assist.getAttribute('class');
            const visibility = await assist.getCSSProperty('visibility');
            isHidden = klass.indexOf('visible') < 0 || visibility.value === 'hidden';
        }
        catch (err) {
            isHidden = true;
        }
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        if (open) {
            if (isHidden) {
                await inputarea.addValue([constants_1.CMD_KEY, 'Space']);
                await browser.$(this.locatorMap.ContentAssist.elem)
                    .waitForExist({ timeout: 2000 });
            }
            const assist = await new __1.ContentAssist(this.locatorMap, this).wait();
            await browser.waitUntil(() => assist.isLoaded(), { timeout: 10000 });
            return assist;
        }
        if (!isHidden) {
            await inputarea.addValue(['Escape']);
        }
        return undefined;
    }
    /**
     * Get all text from the editor
     * @returns Promise resolving to editor text
     */
    async getText() {
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        await inputarea.addValue([constants_1.CMD_KEY, 'a', 'c']);
        const text = clipboardy_1.default.readSync();
        await inputarea.addValue(['ArrowUp']);
        clipboardy_1.default.writeSync('');
        /**
         * let's return "" if the editor is empty rather than "\n"
         */
        return text.trim().length === 0
            ? ''
            : text;
    }
    /**
     * Replace the contents of the editor with a given text
     * @param text text to type into the editor
     * @param formatText format the new text, default false
     * @returns Promise resolving once the new text is copied over
     */
    async setText(text, formatText = false) {
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        clipboardy_1.default.writeSync(text);
        await inputarea.addValue([constants_1.CMD_KEY, 'a', 'v']);
        clipboardy_1.default.writeSync('');
        if (formatText) {
            await this.formatDocument();
        }
    }
    /**
     * Deletes all text within the editor
     * @returns Promise resolving once the text is deleted
     */
    async clearText() {
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        await inputarea.addValue([constants_1.CMD_KEY, 'a', 'Backspace']);
    }
    /**
     * Get text from a given line
     * @param line number of the line to retrieve
     * @returns Promise resolving to text at the given line number
     */
    async getTextAtLine(line) {
        const text = await this.getText();
        const lines = text.split('\n');
        if (line < 1 || line > lines.length) {
            throw new Error(`Line number ${line} does not exist`);
        }
        return lines[line - 1].trim();
    }
    /**
     * Replace the contents of a line with a given text
     * @param line number of the line to edit
     * @param text text to set at the line
     * @returns Promise resolving when the text is typed in
     */
    async setTextAtLine(line, text) {
        if (line < 1 || line > await this.getNumberOfLines()) {
            throw new Error(`Line number ${line} does not exist`);
        }
        const lines = (await this.getText()).split('\n');
        lines[line - 1] = text;
        await this.setText(lines.join('\n'));
    }
    /**
     * Get line number that contains the given text. Not suitable for multi line inputs.
     *
     * @param text text to search for
     * @param occurrence select which occurrence of the search text to look for in case
     *                   there are multiple in the document, defaults to 1 (the first instance)
     *
     * @returns Number of the line that contains the start of the given text. -1 if no such text is found.
     * If occurrence number is specified, searches until it finds as many instances of the given text.
     * Returns the line number that holds the last occurrence found this way.
     */
    async getLineOfText(text, occurrence = 1) {
        let lineNum = -1;
        let found = 0;
        const lines = (await this.getText()).split('\n');
        for (let i = 0; i < lines.length; i += 1) {
            if (lines[i].includes(text)) {
                found += 1;
                lineNum = i + 1;
                if (found >= occurrence) {
                    break;
                }
            }
        }
        return lineNum;
    }
    /**
     * Find and select a given text. Not usable for multi line selection.
     *
     * @param text text to select
     * @param occurrence specify which onccurrence of text to select if multiple are present in the document
     */
    async selectText(text, occurrence = 1) {
        const lineNum = await this.getLineOfText(text, occurrence);
        if (lineNum < 1) {
            throw new Error(`Text '${text}' not found`);
        }
        const line = await this.getTextAtLine(lineNum);
        const column = line.indexOf(text) + 1;
        await this.moveCursor(lineNum, column);
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        await inputarea.addValue([constants_1.CMD_KEY, 'Shift', 'ArrowRight']);
    }
    /**
     * Get the text that is currently selected as string
     */
    async getSelectedText() {
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        await inputarea.addValue([constants_1.CMD_KEY, 'c']);
        return clipboardy_1.default.read();
    }
    /**
     * Get the selection block as a page object
     * @returns Selection page object
     */
    async getSelection() {
        const selection = await this.selection$$;
        if (selection.length < 1) {
            return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new Selection(this.locatorMap, selection[0], this);
    }
    async openFindWidget() {
        await browser.keys([constants_1.CMD_KEY, 'f']);
        const widget = await browser.$(this.locators.findWidget);
        await widget.waitForDisplayed({ timeout: 2000 });
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return new FindWidget(this.locatorMap, widget, this);
    }
    /**
     * Add the given text to the given coordinates
     * @param line number of the line to type into
     * @param column number of the column to start typing at
     * @param text text to add
     * @returns Promise resolving when the text is typed in
     */
    async typeTextAt(line, column, text) {
        await this.moveCursor(line, column);
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        await inputarea.addValue(text);
    }
    /**
     * Type given text at the current coordinates
     * @param text text to type
     * @returns promise resolving when the text is typed in
     */
    async typeText(text) {
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        await inputarea.addValue(text);
    }
    /**
     * Move the cursor to the given coordinates
     * @param line line number to move to
     * @param column column number to move to
     * @returns Promise resolving when the cursor has reached the given coordinates
     */
    async moveCursor(line, column) {
        if (line < 1 || line > await this.getNumberOfLines()) {
            throw new Error(`Line number ${line} does not exist`);
        }
        if (column < 1) {
            throw new Error(`Column number ${column} does not exist`);
        }
        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea);
        let coordinates = await this.getCoordinates();
        const lineGap = coordinates[0] - line;
        const lineKey = lineGap >= 0 ? 'ArrowUp' : 'ArrowDown';
        for (let i = 0; i < Math.abs(lineGap); i += 1) {
            await inputarea.addValue([lineKey]);
        }
        // eslint-disable-next-line wdio/no-pause
        await browser.pause(100);
        coordinates = await this.getCoordinates();
        const columnGap = coordinates[1] - column;
        const columnKey = columnGap >= 0 ? 'ArrowLeft' : 'ArrowRight';
        for (let i = 0; i < Math.abs(columnGap); i += 1) {
            await inputarea.addValue([columnKey]);
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(50);
            if ((await this.getCoordinates())[0] !== coordinates[0]) {
                throw new Error(`Column number ${column} is not accessible on line ${line}`);
            }
        }
    }
    /**
     * Get number of lines in the editor
     * @returns Promise resolving to number of lines
     */
    async getNumberOfLines() {
        const lines = (await this.getText()).split('\n');
        return lines.length;
    }
    /**
     * Use the built-in 'Format Document' option to format the text
     * @returns Promise resolving when the Format Document command is invoked
     */
    async formatDocument() {
        const menu = await this.openContextMenu();
        try {
            await menu.select('Format Document');
        }
        catch (err) {
            console.log('Warn: Format Document not available for selected language');
            if (await menu.elem.isDisplayed()) {
                await menu.close();
            }
        }
    }
    async openContextMenu() {
        await this.elem.click({ button: 2 });
        const shadowRootHost = await this.view.elem.$$('.shadow-root-host');
        if (shadowRootHost.length > 0) {
            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]));
            return new __1.ContextMenu(this.locatorMap, shadowRoot).wait();
        }
        return super.openContextMenu();
    }
    /**
     * Get the cursor's coordinates as an array of two numbers: `[line, column]`
     *
     * **Caution** line & column coordinates do not start at `0` but at `1`!
     */
    async getCoordinates() {
        const coords = [];
        const statusBar = new StatusBar_1.StatusBar(this.locatorMap);
        const coordinates = (await statusBar.getCurrentPosition()).match(/\d+/g);
        for (const c of coordinates) {
            coords.push(+c);
        }
        return [coords[0], coords[1]];
    }
    /**
     * Toggle breakpoint on a given line
     *
     * @param line target line number
     * @returns promise resolving to true when a breakpoint was added, false when removed or
     */
    async toggleBreakpoint(line) {
        const margin = await this.marginArea$;
        const lineNum = await margin.$(this.locators.lineNumber(line));
        await lineNum.moveTo();
        const lineOverlay = await margin.$(this.locators.lineOverlay(line));
        const breakPoint = await lineOverlay.$$(this.locators.breakPoint);
        if (breakPoint.length > 0) {
            await breakPoint[0].click();
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(200);
            return false;
        }
        const noBreak = await lineOverlay.$$(this.locators.debugHint);
        if (noBreak.length > 0) {
            await noBreak[0].click();
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(200);
            return true;
        }
        return false;
    }
    /**
     * Get all code lenses within the editor
     * @returns list of CodeLens page objects
     */
    async getCodeLenses() {
        const lenses = [];
        const widgets = await this.elem.$('.contentWidgets');
        const items = await widgets.$$('.//span[contains(@widgetid, \'codelens.widget\')]');
        for (const item of items) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            lenses.push(await new CodeLens(this.locatorMap, item, this).wait());
        }
        return lenses;
    }
    /**
     * Get a code lens based on title, or zero based index
     *
     * @param indexOrTitle zero based index (counting from the top of the editor), or partial title of the code lens
     * @returns CodeLens object if such a code lens exists, undefined otherwise
     */
    async getCodeLens(indexOrTitle) {
        const lenses = await this.getCodeLenses();
        if (typeof indexOrTitle === 'string') {
            for (const lens of lenses) {
                const title = await lens.getText();
                const match = title.match(indexOrTitle);
                if (match && match.length > 0) {
                    return lens;
                }
            }
        }
        else if (lenses[indexOrTitle]) {
            return lenses[indexOrTitle];
        }
        return undefined;
    }
};
TextEditor = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.TextEditor)
], TextEditor);
exports.TextEditor = TextEditor;
/**
 * Text selection block
 *
 * @category Editor
 */
let Selection = class Selection extends utils_1.ElementWithContextMenu {
    constructor(locators, element, editor) {
        super(locators, element);
        this.editor = editor;
        /**
         * @private
         */
        this.locatorKey = 'TextEditor';
    }
    async openContextMenu() {
        await this.elem.click({ button: 2 });
        const shadowRootHost = await this.editor.view.elem.$$('.shadow-root-host');
        if (shadowRootHost.length > 0) {
            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]));
            return new __1.ContextMenu(this.locatorMap, shadowRoot).wait();
        }
        return super.openContextMenu();
    }
};
Selection = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.TextEditor)
], Selection);
/**
 * Page object for Code Lens inside a text editor
 *
 * @category Editor
 */
let CodeLens = class CodeLens extends utils_1.BasePage {
    constructor(locators, element, editor) {
        super(locators, element);
        this.editor = editor;
        /**
         * @private
         */
        this.locatorKey = 'TextEditor';
    }
    /**
     * Get the text displayed on the code lens
     * @returns text as string
     */
    async getText() {
        const link = await this.elem.$('a');
        return link.getText();
    }
    /**
     * Get tooltip of the code lens
     * @returns tooltip as string
     */
    async getTooltip() {
        const link = await this.elem.$('a');
        return link.getAttribute('title');
    }
};
CodeLens = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.TextEditor)
], CodeLens);
exports.CodeLens = CodeLens;
/**
 * Text Editor's Find Widget
 *
 * @category Editor
 */
let FindWidget = class FindWidget extends utils_1.BasePage {
    constructor(locators, element, textEditor) {
        super(locators, element);
        this.textEditor = textEditor;
        /**
         * @private
         */
        this.locatorKey = 'FindWidget';
    }
    /**
     * Toggle between find and replace mode
     * @param replace true for replace, false for find
     */
    async toggleReplace(replace) {
        const btn = await this.toggleReplace$;
        const klass = await btn.getAttribute('class');
        if ((replace && klass.includes('collapsed')) || (!replace && !klass.includes('collapsed'))) {
            await btn.addValue([' ']);
            const repl = await browser.$(this.locators.replacePart);
            await repl.waitForExist({ timeout: 2000 });
            if (replace) {
                await repl.waitForDisplayed({ timeout: 2000 });
            }
            else {
                await repl.waitForDisplayed({ timeout: 2000, reverse: true });
            }
        }
    }
    /**
     * Set text in the search box
     * @param text text to fill in
     */
    async setSearchText(text) {
        await browser.keys([constants_1.CMD_KEY, 'f']);
        await browser.keys(text);
    }
    /**
     * Get text from Find input box
     * @returns value of find input as string
     */
    async getSearchText() {
        const findPart = await this.findPart$;
        return this.getInputText(findPart);
    }
    /**
     * Set text in the replace box. Will toggle replace mode on if called in find mode.
     * @param text text to fill in
     */
    async setReplaceText(text) {
        await this.toggleReplace(true);
        const replacePart = await this.replacePart$;
        await this.setText(text, replacePart);
    }
    /**
     * Get text from Replace input box
     * @returns value of replace input as string
     */
    async getReplaceText() {
        const replacePart = await this.replacePart$;
        return this.getInputText(replacePart);
    }
    /**
     * Click 'Next match'
     */
    async nextMatch() {
        const name = (await browser.getVSCodeVersion()) < '1.59.0' ? 'Next match' : 'Next Match';
        await this.clickButton(name, 'find');
    }
    /**
     * Click 'Previous match'
     */
    async previousMatch() {
        const name = (await browser.getVSCodeVersion()) < '1.59.0' ? 'Previous match' : 'Previous Match';
        await this.clickButton(name, 'find');
    }
    /**
     * Click 'Replace'. Only works in replace mode.
     */
    async replace() {
        await this.clickButton('Replace', 'replace');
    }
    /**
     * Click 'Replace All'. Only works in replace mode.
     */
    async replaceAll() {
        await this.clickButton('Replace All', 'replace');
    }
    /**
     * Close the widget.
     */
    async close() {
        await this.clickButton('Close', 'find');
    }
    /**
     * Get the number of results as an ordered pair of numbers
     * @returns pair in form of [current result index, total number of results]
     */
    async getResultCount() {
        const count = await this.matchCount$;
        const text = await count.getText();
        if (text.includes('No results')) {
            return [0, 0];
        }
        const numbers = text.split(' of ');
        return [+numbers[0], +numbers[1]];
    }
    /**
     * Toggle the search to match case
     * @param toggle true to turn on, false to turn off
     */
    async toggleMatchCase(toggle) {
        await this.toggleControl('Match Case', 'find', toggle);
    }
    /**
     * Toggle the search to match whole words
     * @param toggle true to turn on, false to turn off
     */
    async toggleMatchWholeWord(toggle) {
        await this.toggleControl('Match Whole Word', 'find', toggle);
    }
    /**
     * Toggle the search to use regular expressions
     * @param toggle true to turn on, false to turn off
     */
    async toggleUseRegularExpression(toggle) {
        await this.toggleControl('Use Regular Expression', 'find', toggle);
    }
    /**
     * Toggle the replace to preserve case
     * @param toggle true to turn on, false to turn off
     */
    async togglePreserveCase(toggle) {
        await this.toggleControl('Preserve Case', 'replace', toggle);
    }
    async toggleControl(title, part, toggle) {
        if (part !== 'find' && part !== 'replace') {
            throw new Error('"part" parameter needs to be "find" or "replace"');
        }
        const element = part === 'find'
            ? await this.findPart$
            : await this.replacePart$;
        if (part === 'replace') {
            await this.toggleReplace(true);
        }
        const control = await element.$(this.locators.checkbox(title));
        const checked = await control.getAttribute('aria-checked');
        if ((toggle && checked !== 'true') || (!toggle && checked === 'true')) {
            await control.click();
        }
    }
    async clickButton(title, part) {
        if (part !== 'find' && part !== 'replace') {
            throw new Error('"part" parameter needs to be "find" or "replace"');
        }
        const element = part === 'find'
            ? await this.findPart$
            : await this.replacePart$;
        if (part === 'replace') {
            await this.toggleReplace(true);
        }
        const btn = await element.$(this.locators.button(title));
        await btn.click();
        // eslint-disable-next-line wdio/no-pause
        await browser.pause(100);
    }
    async setText(text, composite) {
        const input = await composite.$(this.locators.input);
        await input.setValue(text);
    }
    async getInputText(composite) {
        const input = await composite.$(this.locators.content);
        return input.getHTML(false);
    }
};
FindWidget = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.FindWidget)
], FindWidget);
exports.FindWidget = FindWidget;
//# sourceMappingURL=TextEditor.js.map