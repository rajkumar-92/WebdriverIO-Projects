"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkSetting = exports.CheckboxSetting = exports.TextSetting = exports.ComboSetting = exports.Setting = exports.SettingsEditor = void 0;
const Editor_1 = require("./Editor");
const __1 = require("..");
const utils_1 = require("../utils");
const _1_73_0_1 = require("../../locators/1.73.0");
/**
 * Page object representing the internal VSCode settings editor
 *
 * @category Editor
 */
let SettingsEditor = class SettingsEditor extends Editor_1.Editor {
    constructor(locators, view) {
        super(locators, view?.elem);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
        this.view = view || new __1.EditorView(this.locatorMap);
    }
    /**
     * Search for a setting with a particular title and category.
     * Returns an appropriate Setting object if the label is found,
     * undefined otherwise.
     *
     * If your setting has nested categories (i.e `example.general.test`),
     * pass in each category as a separate string.
     *
     * @param title title of the setting
     * @param categories category of the setting
     * @returns Promise resolving to a Setting object if found, undefined otherwise
     */
    async findSetting(title, ...categories) {
        const category = categories.join(' â€º ');
        const searchBox = await this.elem.$(this.locatorMap.Editor.inputArea);
        await searchBox.setValue(`${category}: ${title}`);
        const count = await this.itemCount$;
        let textCount = await count.getText();
        await browser.waitUntil(async () => {
            await (0, utils_1.sleep)(1500);
            const text = await count.getText();
            if (text !== textCount) {
                textCount = text;
                return false;
            }
            return true;
        });
        let setting;
        const items = await this.itemRow$$;
        for (const item of items) {
            try {
                return await (await this.createSetting(item, title, category)).wait();
            }
            catch (err) {
                // ignore
            }
        }
        return setting;
    }
    /**
     * Switch between settings perspectives
     * Works only if your vscode instance has both user and workspace settings available
     *
     * @param perspective User or Workspace
     * @returns Promise that resolves when the appropriate button is clicked
     */
    async switchToPerspective(perspective) {
        await this.header$
            .$(this.locators.tabs)
            .$(this.locators.actions)
            .$(this.locators.action(perspective))
            .click();
    }
    /**
     * Context menu is disabled in this editor, throw an error
     */
    openContextMenu() {
        throw new Error('Operation not supported');
    }
    async createSetting(element, title, category) {
        if (!await element.$(this.locators.settingConstructor(title, category)).isExisting()) {
            throw new Error('Setting not found');
        }
        // try a combo setting
        if (await element.$(this.locators.comboSetting).isExisting()) {
            return new ComboSetting(this.locatorMap, title, category, this);
        }
        // try text setting
        if (await element.$(this.locators.textSetting).isExisting()) {
            return new TextSetting(this.locatorMap, title, category, this);
        }
        // try checkbox setting
        if (await element.$(this.locators.checkboxSetting).isExisting()) {
            return new CheckboxSetting(this.locatorMap, title, category, this);
        }
        // try link setting
        if (await element.$(this.locators.linkButton).isExisting()) {
            return new LinkSetting(this.locatorMap, title, category, this);
        }
        throw new Error('Setting type not supported');
    }
};
SettingsEditor = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.SettingsEditor)
], SettingsEditor);
exports.SettingsEditor = SettingsEditor;
/**
 * Abstract item representing a Setting with title, description and
 * an input element (combo/textbox/checkbox/link)
 *
 * @category Editor
 */
class Setting extends utils_1.BasePage {
    constructor(locators, title, category, settings) {
        super(locators, locators.SettingsEditor.settingConstructor(title, category));
        this.settings = settings;
        this.title = title;
        this.category = category;
    }
    /**
     * Get the category of the setting
     * All settings are labeled as Category: Title
     */
    getCategory() {
        return this.category;
    }
    /**
     * Get description of the setting
     * @returns Promise resolving to setting description
     */
    async getDescription() {
        return this.settingDesctiption$.getText();
    }
    /**
     * Get title of the setting
     */
    getTitle() {
        return this.title;
    }
}
exports.Setting = Setting;
/**
 * Setting with a combo box
 *
 * @category Editor
 */
let ComboSetting = class ComboSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        return this.comboSetting$.getAttribute('title');
    }
    async setValue(value) {
        const rows = await this.getOptions();
        for (let i = 0; i < rows.length; i += 1) {
            if ((await rows[i].getAttribute('class')).indexOf('disabled') < 0) {
                const text = await rows[i].$(this.locators.comboOption).getText();
                if (value === text) {
                    await rows[i].click();
                    return;
                }
            }
        }
    }
    /**
     * Get the labels of all options from the combo
     * @returns Promise resolving to array of string values
     */
    async getValues() {
        const values = [];
        const rows = await this.getOptions();
        for (const row of rows) {
            values.push(await row.$(this.locators.comboOption).getText());
        }
        return values;
    }
    async getOptions() {
        const menu = await this.openCombo();
        return menu.$$(this.locators.itemRow);
    }
    async openCombo() {
        const combo = await this.comboSetting$;
        const workbench = await browser.$(this.locatorMap.Workbench.elem);
        const menus = await workbench.$$(this.locatorMap.ContextMenu.contextView);
        let menu;
        if (menus.length < 1) {
            await combo.click();
            menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
            return menu;
        }
        if (await menus[0].isDisplayed()) {
            await combo.click();
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(200);
        }
        await combo.click();
        menu = await workbench.$(this.locatorMap.ContextMenu.contextView);
        return menu;
    }
};
ComboSetting = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.SettingsEditor)
], ComboSetting);
exports.ComboSetting = ComboSetting;
/**
 * Setting with a text box input
 *
 * @category Editor
 */
let TextSetting = class TextSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        return this.textSetting$.getAttribute('value');
    }
    async setValue(value) {
        const input = await this.textSetting$;
        await input.setValue(value);
    }
};
TextSetting = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.SettingsEditor)
], TextSetting);
exports.TextSetting = TextSetting;
/**
 * Setting with a checkbox
 *
 * @category Editor
 */
let CheckboxSetting = class CheckboxSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    async getValue() {
        const checked = await this.checkboxSetting$.getAttribute(this.locators.checkboxChecked);
        if (checked === 'true') {
            return true;
        }
        return false;
    }
    async setValue(value) {
        if (await this.getValue() !== value) {
            await this.checkboxSetting$.click();
        }
    }
};
CheckboxSetting = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.SettingsEditor)
], CheckboxSetting);
exports.CheckboxSetting = CheckboxSetting;
/**
 * Setting with no value, with a link to settings.json instead
 *
 * @category Editor
 */
let LinkSetting = class LinkSetting extends Setting {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'SettingsEditor';
    }
    getValue() {
        throw new Error('Method getValue is not available for LinkSetting');
    }
    setValue() {
        throw new Error('Method setValue is not available for LinkSetting');
    }
    /**
     * Open the link that leads to the value in settings.json
     * @returns Promise resolving when the link has been clicked
     */
    async openLink() {
        await this.linkButton$.click();
    }
};
LinkSetting = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.SettingsEditor)
], LinkSetting);
exports.LinkSetting = LinkSetting;
//# sourceMappingURL=SettingsEditor.js.map