{"version":3,"file":"TextEditor.js","sourceRoot":"","sources":["../../../src/pageobjects/editor/TextEditor.ts"],"names":[],"mappings":"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","sourcesContent":["import { fileURLToPath } from 'url'\nimport clipboard from 'clipboardy'\nimport type { ChainablePromiseElement } from 'webdriverio'\n\nimport { ContentAssist, ContextMenu, InputBox } from '..'\nimport { StatusBar } from '../statusBar/StatusBar'\nimport { Editor, EditorLocators } from './Editor'\n\nimport {\n    PageDecorator, IPageDecorator, BasePage, ElementWithContextMenu, VSCodeLocatorMap\n} from '../utils'\nimport {\n    TextEditor as TextEditorLocators,\n    FindWidget as FindWidgetLocators\n} from '../../locators/1.73.0'\nimport { CMD_KEY } from '../../constants'\n\nexport interface TextEditor extends IPageDecorator<EditorLocators> {}\n/**\n * Page object representing the active text editor\n *\n * @category Editor\n */\n@PageDecorator(TextEditorLocators)\nexport class TextEditor extends Editor<EditorLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'TextEditor' as const\n\n    /**\n     * Find whether the active editor has unsaved changes\n     * @returns Promise resolving to true/false\n     */\n    async isDirty (): Promise<boolean> {\n        const klass = await this.parent.$(this.locators.activeTab).getAttribute('class')\n        return klass.indexOf('dirty') >= 0\n    }\n\n    /**\n     * Saves the active editor\n     * @returns Promise resolving when ctrl+s is invoked\n     */\n    async save (): Promise<void> {\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        await inputarea.addValue([CMD_KEY, 's'])\n    }\n\n    /**\n     * Open the Save as prompt\n     *\n     * @returns InputBox serving as a simple file dialog\n     */\n    async saveAs (): Promise<InputBox> {\n        const tab = await this.getTab()\n        await tab.elem.addValue([CMD_KEY, 'Shift', 's'])\n        const inputBox = browser.$(this.locatorMap.InputBox.elem as string)\n        await inputBox.waitForExist({ timeout: 5000 })\n        return new InputBox(this.locatorMap, inputBox)\n    }\n\n    /**\n     * Retrieve the Uri of the file opened in the active editor\n     * @returns Promise resolving to editor's underlying Uri\n     */\n    async getFileUri (): Promise<string> {\n        const ed = await this.editorContainer$\n        return ed.getAttribute(this.locators.dataUri)\n    }\n\n    /**\n     * Retrieve the path to the file opened in the active editor\n     * @returns Promise resolving to editor's underlying file path\n     */\n    async getFilePath (): Promise<string> {\n        return fileURLToPath(await this.getFileUri())\n    }\n\n    /**\n     * Open/Close the content assistant at the current position in the editor by sending the default\n     * keyboard shortcut signal\n     * @param open true to open, false to close\n     * @returns Promise resolving to ContentAssist object when opening, void otherwise\n     */\n    async toggleContentAssist (open: boolean): Promise<ContentAssist | undefined> {\n        let isHidden = true\n        try {\n            const assist = await this.elem.$(this.locatorMap.ContentAssist.elem as string)\n            const klass = await assist.getAttribute('class')\n            const visibility = await assist.getCSSProperty('visibility')\n            isHidden = klass.indexOf('visible') < 0 || visibility.value === 'hidden'\n        } catch (err) {\n            isHidden = true\n        }\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n\n        if (open) {\n            if (isHidden) {\n                await inputarea.addValue([CMD_KEY, 'Space'])\n                await browser.$(this.locatorMap.ContentAssist.elem as string)\n                    .waitForExist({ timeout: 2000 })\n            }\n            const assist = await new ContentAssist(this.locatorMap, this).wait()\n            await browser.waitUntil(() => assist.isLoaded(), { timeout: 10000 })\n            return assist\n        }\n        if (!isHidden) {\n            await inputarea.addValue(['Escape'])\n        }\n        return undefined\n    }\n\n    /**\n     * Get all text from the editor\n     * @returns Promise resolving to editor text\n     */\n    async getText (): Promise<string> {\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        await inputarea.addValue([CMD_KEY, 'a', 'c'])\n        const text = clipboard.readSync()\n        await inputarea.addValue(['ArrowUp'])\n        clipboard.writeSync('')\n\n        /**\n         * let's return \"\" if the editor is empty rather than \"\\n\"\n         */\n        return text.trim().length === 0\n            ? ''\n            : text\n    }\n\n    /**\n     * Replace the contents of the editor with a given text\n     * @param text text to type into the editor\n     * @param formatText format the new text, default false\n     * @returns Promise resolving once the new text is copied over\n     */\n    async setText (text: string, formatText = false): Promise<void> {\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        clipboard.writeSync(text)\n        await inputarea.addValue([CMD_KEY, 'a', 'v'])\n        clipboard.writeSync('')\n        if (formatText) {\n            await this.formatDocument()\n        }\n    }\n\n    /**\n     * Deletes all text within the editor\n     * @returns Promise resolving once the text is deleted\n     */\n    async clearText (): Promise<void> {\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        await inputarea.addValue([CMD_KEY, 'a', 'Backspace'])\n    }\n\n    /**\n     * Get text from a given line\n     * @param line number of the line to retrieve\n     * @returns Promise resolving to text at the given line number\n     */\n    async getTextAtLine (line: number): Promise<string> {\n        const text = await this.getText()\n        const lines = text.split('\\n')\n        if (line < 1 || line > lines.length) {\n            throw new Error(`Line number ${line} does not exist`)\n        }\n        return lines[line - 1].trim()\n    }\n\n    /**\n     * Replace the contents of a line with a given text\n     * @param line number of the line to edit\n     * @param text text to set at the line\n     * @returns Promise resolving when the text is typed in\n     */\n    async setTextAtLine (line: number, text: string): Promise<void> {\n        if (line < 1 || line > await this.getNumberOfLines()) {\n            throw new Error(`Line number ${line} does not exist`)\n        }\n        const lines = (await this.getText()).split('\\n')\n        lines[line - 1] = text\n        await this.setText(lines.join('\\n'))\n    }\n\n    /**\n     * Get line number that contains the given text. Not suitable for multi line inputs.\n     *\n     * @param text text to search for\n     * @param occurrence select which occurrence of the search text to look for in case\n     *                   there are multiple in the document, defaults to 1 (the first instance)\n     *\n     * @returns Number of the line that contains the start of the given text. -1 if no such text is found.\n     * If occurrence number is specified, searches until it finds as many instances of the given text.\n     * Returns the line number that holds the last occurrence found this way.\n     */\n    async getLineOfText (text: string, occurrence = 1): Promise<number> {\n        let lineNum = -1\n        let found = 0\n        const lines = (await this.getText()).split('\\n')\n\n        for (let i = 0; i < lines.length; i += 1) {\n            if (lines[i].includes(text)) {\n                found += 1\n                lineNum = i + 1\n                if (found >= occurrence) {\n                    break\n                }\n            }\n        }\n        return lineNum\n    }\n\n    /**\n     * Find and select a given text. Not usable for multi line selection.\n     *\n     * @param text text to select\n     * @param occurrence specify which onccurrence of text to select if multiple are present in the document\n     */\n    async selectText (text: string, occurrence = 1): Promise<void> {\n        const lineNum = await this.getLineOfText(text, occurrence)\n        if (lineNum < 1) {\n            throw new Error(`Text '${text}' not found`)\n        }\n\n        const line = await this.getTextAtLine(lineNum)\n        const column = line.indexOf(text) + 1\n\n        await this.moveCursor(lineNum, column)\n\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        await inputarea.addValue([CMD_KEY, 'Shift', 'ArrowRight'])\n    }\n\n    /**\n     * Get the text that is currently selected as string\n     */\n    async getSelectedText (): Promise<string> {\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        await inputarea.addValue([CMD_KEY, 'c'])\n        return clipboard.read()\n    }\n\n    /**\n     * Get the selection block as a page object\n     * @returns Selection page object\n     */\n    async getSelection (): Promise<Selection | undefined> {\n        const selection = await this.selection$$\n        if (selection.length < 1) {\n            return undefined\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new Selection(this.locatorMap, selection[0] as any, this)\n    }\n\n    async openFindWidget (): Promise<FindWidget> {\n        await browser.keys([CMD_KEY, 'f'])\n        const widget = await browser.$(this.locators.findWidget)\n        await widget.waitForDisplayed({ timeout: 2000 })\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new FindWidget(this.locatorMap, widget as any, this)\n    }\n\n    /**\n     * Add the given text to the given coordinates\n     * @param line number of the line to type into\n     * @param column number of the column to start typing at\n     * @param text text to add\n     * @returns Promise resolving when the text is typed in\n     */\n    async typeTextAt (line: number, column: number, text: string): Promise<void> {\n        await this.moveCursor(line, column)\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        await inputarea.addValue(text)\n    }\n\n    /**\n     * Type given text at the current coordinates\n     * @param text text to type\n     * @returns promise resolving when the text is typed in\n     */\n    async typeText (text: string): Promise<void> {\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        await inputarea.addValue(text)\n    }\n\n    /**\n     * Move the cursor to the given coordinates\n     * @param line line number to move to\n     * @param column column number to move to\n     * @returns Promise resolving when the cursor has reached the given coordinates\n     */\n    async moveCursor (line: number, column: number): Promise<void> {\n        if (line < 1 || line > await this.getNumberOfLines()) {\n            throw new Error(`Line number ${line} does not exist`)\n        }\n        if (column < 1) {\n            throw new Error(`Column number ${column} does not exist`)\n        }\n        const inputarea = await this.elem.$(this.locatorMap.Editor.inputArea as string)\n        let coordinates = await this.getCoordinates()\n        const lineGap = coordinates[0] - line\n        const lineKey = lineGap >= 0 ? 'ArrowUp' : 'ArrowDown'\n        for (let i = 0; i < Math.abs(lineGap); i += 1) {\n            await inputarea.addValue([lineKey])\n        }\n\n        // eslint-disable-next-line wdio/no-pause\n        await browser.pause(100)\n        coordinates = await this.getCoordinates()\n        const columnGap = coordinates[1] - column\n        const columnKey = columnGap >= 0 ? 'ArrowLeft' : 'ArrowRight'\n        for (let i = 0; i < Math.abs(columnGap); i += 1) {\n            await inputarea.addValue([columnKey])\n            // eslint-disable-next-line wdio/no-pause\n            await browser.pause(50)\n            if ((await this.getCoordinates())[0] !== coordinates[0]) {\n                throw new Error(`Column number ${column} is not accessible on line ${line}`)\n            }\n        }\n    }\n\n    /**\n     * Get number of lines in the editor\n     * @returns Promise resolving to number of lines\n     */\n    async getNumberOfLines (): Promise<number> {\n        const lines = (await this.getText()).split('\\n')\n        return lines.length\n    }\n\n    /**\n     * Use the built-in 'Format Document' option to format the text\n     * @returns Promise resolving when the Format Document command is invoked\n     */\n    async formatDocument (): Promise<void> {\n        const menu = await this.openContextMenu()\n        try {\n            await menu.select('Format Document')\n        } catch (err) {\n            console.log('Warn: Format Document not available for selected language')\n            if (await menu.elem.isDisplayed()) {\n                await menu.close()\n            }\n        }\n    }\n\n    async openContextMenu (): Promise<ContextMenu> {\n        await this.elem.click({ button: 2 })\n        const shadowRootHost = await this.view.elem.$$('.shadow-root-host')\n\n        if (shadowRootHost.length > 0) {\n            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]))\n            return new ContextMenu(this.locatorMap, shadowRoot).wait()\n        }\n        return super.openContextMenu()\n    }\n\n    /**\n     * Get the cursor's coordinates as an array of two numbers: `[line, column]`\n     *\n     * **Caution** line & column coordinates do not start at `0` but at `1`!\n     */\n    async getCoordinates (): Promise<[number, number]> {\n        const coords: number[] = []\n        const statusBar = new StatusBar(this.locatorMap)\n        const coordinates = <RegExpMatchArray>(await statusBar.getCurrentPosition()).match(/\\d+/g)\n        for (const c of coordinates) {\n            coords.push(+c)\n        }\n        return [coords[0], coords[1]]\n    }\n\n    /**\n     * Toggle breakpoint on a given line\n     *\n     * @param line target line number\n     * @returns promise resolving to true when a breakpoint was added, false when removed or\n     */\n    async toggleBreakpoint (line: number): Promise<boolean> {\n        const margin = await this.marginArea$\n        const lineNum = await margin.$(this.locators.lineNumber(line))\n        await lineNum.moveTo()\n\n        const lineOverlay = await margin.$(this.locators.lineOverlay(line))\n        const breakPoint = await lineOverlay.$$(this.locators.breakPoint)\n        if (breakPoint.length > 0) {\n            await breakPoint[0].click()\n            // eslint-disable-next-line wdio/no-pause\n            await browser.pause(200)\n            return false\n        }\n\n        const noBreak = await lineOverlay.$$(this.locators.debugHint)\n        if (noBreak.length > 0) {\n            await noBreak[0].click()\n            // eslint-disable-next-line wdio/no-pause\n            await browser.pause(200)\n            return true\n        }\n        return false\n    }\n\n    /**\n     * Get all code lenses within the editor\n     * @returns list of CodeLens page objects\n     */\n    async getCodeLenses (): Promise<CodeLens[]> {\n        const lenses: CodeLens[] = []\n        const widgets = await this.elem.$('.contentWidgets')\n        const items = await widgets.$$('.//span[contains(@widgetid, \\'codelens.widget\\')]')\n\n        for (const item of items) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            lenses.push(await new CodeLens(this.locatorMap, item as any, this).wait())\n        }\n        return lenses\n    }\n\n    /**\n     * Get a code lens based on title, or zero based index\n     *\n     * @param indexOrTitle zero based index (counting from the top of the editor), or partial title of the code lens\n     * @returns CodeLens object if such a code lens exists, undefined otherwise\n     */\n    async getCodeLens (indexOrTitle: number | string): Promise<CodeLens | undefined> {\n        const lenses = await this.getCodeLenses()\n\n        if (typeof indexOrTitle === 'string') {\n            for (const lens of lenses) {\n                const title = await lens.getText()\n                const match = title.match(indexOrTitle)\n                if (match && match.length > 0) {\n                    return lens\n                }\n            }\n        } else if (lenses[indexOrTitle]) {\n            return lenses[indexOrTitle]\n        }\n        return undefined\n    }\n}\n\ninterface Selection extends IPageDecorator<typeof TextEditorLocators> {}\n/**\n * Text selection block\n *\n * @category Editor\n */\n@PageDecorator(TextEditorLocators)\nclass Selection extends ElementWithContextMenu<typeof TextEditorLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'TextEditor' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element: ChainablePromiseElement<WebdriverIO.Element>,\n        public editor: TextEditor\n    ) {\n        super(locators, element)\n    }\n\n    async openContextMenu (): Promise<ContextMenu> {\n        await this.elem.click({ button: 2 })\n        const shadowRootHost = await this.editor.view.elem.$$('.shadow-root-host')\n\n        if (shadowRootHost.length > 0) {\n            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]))\n            return new ContextMenu(this.locatorMap, shadowRoot).wait()\n        }\n        return super.openContextMenu()\n    }\n}\n\nexport interface CodeLens extends IPageDecorator<typeof TextEditorLocators> {}\n/**\n * Page object for Code Lens inside a text editor\n *\n * @category Editor\n */\n@PageDecorator(TextEditorLocators)\nexport class CodeLens extends BasePage<typeof TextEditorLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'TextEditor' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element: ChainablePromiseElement<WebdriverIO.Element>,\n        public editor: TextEditor\n    ) {\n        super(locators, element)\n    }\n\n    /**\n     * Get the text displayed on the code lens\n     * @returns text as string\n     */\n    async getText (): Promise<string> {\n        const link = await this.elem.$('a')\n        return link.getText()\n    }\n\n    /**\n     * Get tooltip of the code lens\n     * @returns tooltip as string\n     */\n    async getTooltip (): Promise<string> {\n        const link = await this.elem.$('a')\n        return link.getAttribute('title')\n    }\n}\n\nexport interface FindWidget extends IPageDecorator<typeof FindWidgetLocators> {}\n/**\n * Text Editor's Find Widget\n *\n * @category Editor\n */\n@PageDecorator(FindWidgetLocators)\nexport class FindWidget extends BasePage<typeof FindWidgetLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'FindWidget' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element: ChainablePromiseElement<WebdriverIO.Element>,\n        public textEditor: TextEditor\n    ) {\n        super(locators, element)\n    }\n\n    /**\n     * Toggle between find and replace mode\n     * @param replace true for replace, false for find\n     */\n    async toggleReplace (replace: boolean): Promise<void> {\n        const btn = await this.toggleReplace$\n        const klass = await btn.getAttribute('class')\n\n        if ((replace && klass.includes('collapsed')) || (!replace && !klass.includes('collapsed'))) {\n            await btn.addValue([' '])\n            const repl = await browser.$(this.locators.replacePart)\n            await repl.waitForExist({ timeout: 2000 })\n            if (replace) {\n                await repl.waitForDisplayed({ timeout: 2000 })\n            } else {\n                await repl.waitForDisplayed({ timeout: 2000, reverse: true })\n            }\n        }\n    }\n\n    /**\n     * Set text in the search box\n     * @param text text to fill in\n     */\n    async setSearchText (text: string): Promise<void> {\n        await browser.keys([CMD_KEY, 'f'])\n        await browser.keys(text)\n    }\n\n    /**\n     * Get text from Find input box\n     * @returns value of find input as string\n     */\n    async getSearchText (): Promise<string> {\n        const findPart = await this.findPart$\n        return this.getInputText(findPart)\n    }\n\n    /**\n     * Set text in the replace box. Will toggle replace mode on if called in find mode.\n     * @param text text to fill in\n     */\n    async setReplaceText (text: string): Promise<void> {\n        await this.toggleReplace(true)\n        const replacePart = await this.replacePart$\n        await this.setText(text, replacePart)\n    }\n\n    /**\n     * Get text from Replace input box\n     * @returns value of replace input as string\n     */\n    async getReplaceText (): Promise<string> {\n        const replacePart = await this.replacePart$\n        return this.getInputText(replacePart)\n    }\n\n    /**\n     * Click 'Next match'\n     */\n    async nextMatch (): Promise<void> {\n        const name = (await browser.getVSCodeVersion()) < '1.59.0' ? 'Next match' : 'Next Match'\n        await this.clickButton(name, 'find')\n    }\n\n    /**\n     * Click 'Previous match'\n     */\n    async previousMatch (): Promise<void> {\n        const name = (await browser.getVSCodeVersion()) < '1.59.0' ? 'Previous match' : 'Previous Match'\n        await this.clickButton(name, 'find')\n    }\n\n    /**\n     * Click 'Replace'. Only works in replace mode.\n     */\n    async replace (): Promise<void> {\n        await this.clickButton('Replace', 'replace')\n    }\n\n    /**\n     * Click 'Replace All'. Only works in replace mode.\n     */\n    async replaceAll (): Promise<void> {\n        await this.clickButton('Replace All', 'replace')\n    }\n\n    /**\n     * Close the widget.\n     */\n    async close (): Promise<void> {\n        await this.clickButton('Close', 'find')\n    }\n\n    /**\n     * Get the number of results as an ordered pair of numbers\n     * @returns pair in form of [current result index, total number of results]\n     */\n    async getResultCount (): Promise<[number, number]> {\n        const count = await this.matchCount$\n        const text = await count.getText()\n\n        if (text.includes('No results')) {\n            return [0, 0]\n        }\n        const numbers = text.split(' of ')\n        return [+numbers[0], +numbers[1]]\n    }\n\n    /**\n     * Toggle the search to match case\n     * @param toggle true to turn on, false to turn off\n     */\n    async toggleMatchCase (toggle: boolean) {\n        await this.toggleControl('Match Case', 'find', toggle)\n    }\n\n    /**\n     * Toggle the search to match whole words\n     * @param toggle true to turn on, false to turn off\n     */\n    async toggleMatchWholeWord (toggle: boolean) {\n        await this.toggleControl('Match Whole Word', 'find', toggle)\n    }\n\n    /**\n     * Toggle the search to use regular expressions\n     * @param toggle true to turn on, false to turn off\n     */\n    async toggleUseRegularExpression (toggle: boolean) {\n        await this.toggleControl('Use Regular Expression', 'find', toggle)\n    }\n\n    /**\n     * Toggle the replace to preserve case\n     * @param toggle true to turn on, false to turn off\n     */\n    async togglePreserveCase (toggle: boolean) {\n        await this.toggleControl('Preserve Case', 'replace', toggle)\n    }\n\n    private async toggleControl (title: string, part: 'find' | 'replace', toggle: boolean) {\n        if (part !== 'find' && part !== 'replace') {\n            throw new Error('\"part\" parameter needs to be \"find\" or \"replace\"')\n        }\n\n        const element = part === 'find'\n            ? await this.findPart$\n            : await this.replacePart$\n\n        if (part === 'replace') {\n            await this.toggleReplace(true)\n        }\n\n        const control = await element.$(this.locators.checkbox(title))\n        const checked = await control.getAttribute('aria-checked')\n        if ((toggle && checked !== 'true') || (!toggle && checked === 'true')) {\n            await control.click()\n        }\n    }\n\n    private async clickButton (title: string, part: 'find' | 'replace') {\n        if (part !== 'find' && part !== 'replace') {\n            throw new Error('\"part\" parameter needs to be \"find\" or \"replace\"')\n        }\n\n        const element = part === 'find'\n            ? await this.findPart$\n            : await this.replacePart$\n\n        if (part === 'replace') {\n            await this.toggleReplace(true)\n        }\n\n        const btn = await element.$(this.locators.button(title))\n        await btn.click()\n        // eslint-disable-next-line wdio/no-pause\n        await browser.pause(100)\n    }\n\n    private async setText (text: string, composite: WebdriverIO.Element) {\n        const input = await composite.$(this.locators.input)\n        await input.setValue(text)\n    }\n\n    private async getInputText (composite: WebdriverIO.Element) {\n        const input = await composite.$(this.locators.content)\n        return input.getHTML(false)\n    }\n}\n"]}