{"version":3,"file":"StatusBar.js","sourceRoot":"","sources":["../../../src/pageobjects/statusBar/StatusBar.ts"],"names":[],"mappings":"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","sourcesContent":["import { PageDecorator, IPageDecorator, BasePage } from '../utils'\nimport { StatusBar as StatusBarLocators } from '../../locators/1.73.0'\nimport { NotificationsCenter } from '..'\n\nexport interface StatusBar extends IPageDecorator<typeof StatusBarLocators> {}\n/**\n * Page object for the status bar at the bottom\n *\n * @category Statusbar\n */\n@PageDecorator(StatusBarLocators)\nexport class StatusBar extends BasePage<typeof StatusBarLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'StatusBar' as const\n\n    /**\n     * Retrieve all status bar items currently displayed\n     * @returns Promise resolving to an array of WebElement\n     */\n    async getItems () {\n        const elems = await this.item$$\n        const items: string[] = []\n        for (const elem of elems) {\n            items.push(await elem.getAttribute(this.locators.itemTitle))\n        }\n        return items.map((i) => i.trim()).filter(Boolean)\n    }\n\n    /**\n     * Find status bar item by title/visible label\n     * @param title title of the item\n     * @returns Promise resolving to a WebElement if item is found, to undefined otherwise\n     */\n    async getItem (title: string) {\n        const items = await this.item$$\n        for (const item of items) {\n            if (await item.getAttribute(this.locators.itemTitle) === title) {\n                return item\n            }\n        }\n        return undefined\n    }\n\n    /**\n     * Open the notifications center\n     * @returns Promise resolving to NotificationsCenter object\n     */\n    async openNotificationsCenter (): Promise<NotificationsCenter> {\n        await this.toggleNotificationsCentre(true)\n        return new NotificationsCenter(this.locatorMap)\n    }\n\n    /**\n     * Close the notifications center\n     * @returns Promise resolving when the notifications center is closed\n     */\n    async closeNotificationsCenter (): Promise<void> {\n        await this.toggleNotificationsCentre(false)\n    }\n\n    /**\n     * Open the language selection quick pick\n     * Only works with an open editor\n     * @returns Promise resolving when the language selection is opened\n     */\n    async openLanguageSelection (): Promise<void> {\n        await this.language$.click()\n    }\n\n    /**\n     * Get the current language label text\n     * Only works with an open editor\n     * @returns Promise resolving to string representation of current language\n     */\n    async getCurrentLanguage (): Promise<string> {\n        return this.getPartText(this.locators.language)\n    }\n\n    /**\n     * Open the quick pick for line endings selection\n     * Only works with an open editor\n     * @returns Promise resolving when the line ending selection is opened\n     */\n    async openLineEndingSelection (): Promise<void> {\n        await this.lines$.click()\n    }\n\n    /**\n     * Get the currently selected line ending as text\n     * Only works with an open editor\n     * @returns Promise resolving to string representation of current line ending\n     */\n    async getCurrentLineEnding (): Promise<string> {\n        return this.getPartText(this.locators.lines)\n    }\n\n    /**\n     * Open the encoding selection quick pick\n     * Only works with an open editor\n     * @returns Promise resolving when the encoding selection is opened\n     */\n    async openEncodingSelection (): Promise<void> {\n        await this.encoding$.click()\n    }\n\n    /**\n     * Get the name of the current encoding as text\n     * Only works with an open editor\n     * @returns Promise resolving to string representation of current encoding\n     */\n    async getCurrentEncoding (): Promise<string> {\n        return this.getPartText(this.locators.encoding)\n    }\n\n    /**\n     * Open the indentation selection quick pick\n     * Only works with an open editor\n     * @returns Promise resolving when the indentation selection is opened\n     */\n    async openIndentationSelection (): Promise<void> {\n        await this.indent$.click()\n    }\n\n    /**\n     * Get the current indentation option label as text\n     * Only works with an open editor\n     * @returns Promise resolving to string representation of current indentation\n     */\n    async getCurrentIndentation (): Promise<string> {\n        return this.getPartText(this.locators.indent)\n    }\n\n    /**\n     * Open the line selection input box\n     * Only works with an open editor\n     * @returns Promise resolving when the line selection is opened\n     */\n    async openLineSelection (): Promise<void> {\n        await this.selection$.click()\n    }\n\n    /**\n     * Get the current editor coordinates as text\n     * Only works with an open editor\n     * @returns Promise resolving to string representation of current position in the editor\n     */\n    async getCurrentPosition (): Promise<string> {\n        return this.getPartText(this.locators.selection)\n    }\n\n    /**\n     * Open/Close notification centre\n     * @param open true to open, false to close\n     */\n    private async toggleNotificationsCentre (open: boolean): Promise<void> {\n        let visible = false\n        try {\n            const klass = await browser\n                .$(this.locatorMap.Workbench.elem as string)\n                .$(this.locators.notifications)\n                .getAttribute('class')\n            visible = klass.indexOf('visible') > -1\n        } catch (err) {\n            // element doesn't exist until the button is first clicked\n        }\n        if (visible !== open) {\n            await this.bell$.click()\n        }\n    }\n\n    private async getPartText (locator: string): Promise<string> {\n        return this.elem.$(locator).$('a').getText()\n    }\n}\n"]}