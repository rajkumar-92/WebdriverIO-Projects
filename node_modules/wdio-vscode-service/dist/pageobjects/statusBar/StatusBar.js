"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusBar = void 0;
const utils_1 = require("../utils");
const _1_73_0_1 = require("../../locators/1.73.0");
const __1 = require("..");
/**
 * Page object for the status bar at the bottom
 *
 * @category Statusbar
 */
let StatusBar = class StatusBar extends utils_1.BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'StatusBar';
    }
    /**
     * Retrieve all status bar items currently displayed
     * @returns Promise resolving to an array of WebElement
     */
    async getItems() {
        const elems = await this.item$$;
        const items = [];
        for (const elem of elems) {
            items.push(await elem.getAttribute(this.locators.itemTitle));
        }
        return items.map((i) => i.trim()).filter(Boolean);
    }
    /**
     * Find status bar item by title/visible label
     * @param title title of the item
     * @returns Promise resolving to a WebElement if item is found, to undefined otherwise
     */
    async getItem(title) {
        const items = await this.item$$;
        for (const item of items) {
            if (await item.getAttribute(this.locators.itemTitle) === title) {
                return item;
            }
        }
        return undefined;
    }
    /**
     * Open the notifications center
     * @returns Promise resolving to NotificationsCenter object
     */
    async openNotificationsCenter() {
        await this.toggleNotificationsCentre(true);
        return new __1.NotificationsCenter(this.locatorMap);
    }
    /**
     * Close the notifications center
     * @returns Promise resolving when the notifications center is closed
     */
    async closeNotificationsCenter() {
        await this.toggleNotificationsCentre(false);
    }
    /**
     * Open the language selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the language selection is opened
     */
    async openLanguageSelection() {
        await this.language$.click();
    }
    /**
     * Get the current language label text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current language
     */
    async getCurrentLanguage() {
        return this.getPartText(this.locators.language);
    }
    /**
     * Open the quick pick for line endings selection
     * Only works with an open editor
     * @returns Promise resolving when the line ending selection is opened
     */
    async openLineEndingSelection() {
        await this.lines$.click();
    }
    /**
     * Get the currently selected line ending as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current line ending
     */
    async getCurrentLineEnding() {
        return this.getPartText(this.locators.lines);
    }
    /**
     * Open the encoding selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the encoding selection is opened
     */
    async openEncodingSelection() {
        await this.encoding$.click();
    }
    /**
     * Get the name of the current encoding as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current encoding
     */
    async getCurrentEncoding() {
        return this.getPartText(this.locators.encoding);
    }
    /**
     * Open the indentation selection quick pick
     * Only works with an open editor
     * @returns Promise resolving when the indentation selection is opened
     */
    async openIndentationSelection() {
        await this.indent$.click();
    }
    /**
     * Get the current indentation option label as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current indentation
     */
    async getCurrentIndentation() {
        return this.getPartText(this.locators.indent);
    }
    /**
     * Open the line selection input box
     * Only works with an open editor
     * @returns Promise resolving when the line selection is opened
     */
    async openLineSelection() {
        await this.selection$.click();
    }
    /**
     * Get the current editor coordinates as text
     * Only works with an open editor
     * @returns Promise resolving to string representation of current position in the editor
     */
    async getCurrentPosition() {
        return this.getPartText(this.locators.selection);
    }
    /**
     * Open/Close notification centre
     * @param open true to open, false to close
     */
    async toggleNotificationsCentre(open) {
        let visible = false;
        try {
            const klass = await browser
                .$(this.locatorMap.Workbench.elem)
                .$(this.locators.notifications)
                .getAttribute('class');
            visible = klass.indexOf('visible') > -1;
        }
        catch (err) {
            // element doesn't exist until the button is first clicked
        }
        if (visible !== open) {
            await this.bell$.click();
        }
    }
    async getPartText(locator) {
        return this.elem.$(locator).$('a').getText();
    }
};
StatusBar = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.StatusBar)
], StatusBar);
exports.StatusBar = StatusBar;
//# sourceMappingURL=StatusBar.js.map