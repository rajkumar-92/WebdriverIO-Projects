/// <reference types="webdriverio/async" />
import type { ChainablePromiseElement, ChainablePromiseArray } from 'webdriverio';
import * as allLocatorsTypes from '../locators/insiders';
import { ContextMenu } from '..';
declare type ClassWithFunctionLocatorsAsString<T> = {
    [key in keyof T as T[key] extends Function | undefined ? key : never]: T[key];
};
declare type ClassWithFunctionLocators$<T> = {
    [key in keyof ClassWithFunctionLocatorsAsString<T> as `${key}$`]: (...args: Parameters<ClassWithFunctionLocatorsAsString<T>[key]>) => ChainablePromiseElement<WebdriverIO.Element>;
};
declare type ClassWithFunctionLocators$$<T> = {
    [key in keyof ClassWithFunctionLocatorsAsString<T> as `${key}$$`]: (...args: Parameters<ClassWithFunctionLocatorsAsString<T>[key]>) => ChainablePromiseArray<WebdriverIO.Element[]>;
};
declare type ClassWithLocators$<T> = {
    [key in keyof T & string as T[key] extends String | undefined ? `${key}$` : never]: ChainablePromiseElement<WebdriverIO.Element>;
};
declare type ClassWithLocators$$<T> = {
    [key in keyof T & string as T[key] extends String | undefined ? `${key}$$` : never]: ChainablePromiseArray<WebdriverIO.Element[]>;
};
declare type AllLocatorType = typeof allLocatorsTypes;
export declare type LocatorComponents = keyof AllLocatorType | (keyof AllLocatorType)[];
export declare type Locators = Record<string | symbol, string | Function>;
export declare type VSCodeLocatorMap = Record<keyof AllLocatorType, Locators>;
export declare type IPageDecorator<T> = (ClassWithLocators$<T> & ClassWithLocators$$<T> & ClassWithFunctionLocators$<T> & ClassWithFunctionLocators$$<T>);
declare type PageObjectClass = {
    new (...args: any[]): any;
    [staticMethod: string]: any;
};
export declare function PageDecorator<T extends PageObjectClass>(locators: Locators): (ctor: T) => T;
export declare abstract class BasePage<PageLocators, LocatorMap extends Record<string, Locators> = VSCodeLocatorMap> {
    protected _locators: LocatorMap;
    private _baseElem?;
    private _parentElem?;
    /**
     * @private
     */
    abstract locatorKey: keyof LocatorMap | (keyof LocatorMap)[];
    /**
     * @private
     */
    constructor(_locators: LocatorMap, _baseElem?: string | ChainablePromiseElement<WebdriverIO.Element> | undefined, _parentElem?: string | ChainablePromiseElement<WebdriverIO.Element> | undefined);
    /**
     * Get the locator map of given page object
     */
    get locators(): PageLocators;
    /**
     * @private
     */
    get baseElem(): string | ChainablePromiseElement<WebdriverIO.Element> | undefined;
    /**
     * @private
     */
    get locatorMap(): LocatorMap;
    /**
     * Base element of given page object
     */
    get elem(): ChainablePromiseElement<WebdriverIO.Element>;
    /**
     * Parent element of given page object
     */
    get parent(): ChainablePromiseElement<WebdriverIO.Element>;
    /**
     * @private
     */
    setParentElement(parentElem: string | ChainablePromiseElement<WebdriverIO.Element>): void;
    /**
     * Wait for the element to become visible
     * @param timeout custom timeout for the wait
     * @returns thenable self reference
     */
    wait(timeout?: number): Promise<this>;
}
/**
 * Abstract element that has a context menu
 */
export declare abstract class ElementWithContextMenu<T> extends BasePage<T> {
    /**
     * Open context menu on the element
     */
    openContextMenu(): Promise<ContextMenu>;
}
export declare function sleep(ms?: number): Promise<void>;
export {};
//# sourceMappingURL=utils.d.ts.map