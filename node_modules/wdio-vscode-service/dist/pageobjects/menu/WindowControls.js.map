{"version":3,"file":"WindowControls.js","sourceRoot":"","sources":["../../../src/pageobjects/menu/WindowControls.ts"],"names":[],"mappings":";;;;;;;;;AAEA,oCAEiB;AACjB,6BAAgC;AAChC,mDAAgF;AAGhF;;;;GAIG;AAEI,IAAM,cAAc,GAApB,MAAM,cAAe,SAAQ,gBAAuC;IAMvE,YACI,QAA0B,EAC1B,OAA+D,EACxD,MAAgB,IAAI,YAAQ,CAAC,QAAQ,CAAC;QAE7C,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;QAFjB,QAAG,GAAH,GAAG,CAAmC;QARjD;;WAEG;QACI,eAAU,GAAG,gBAAyB,CAAA;QAQzC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;IACxC,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,QAAQ;QACV,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAA;IAChC,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,QAAQ;QACV,IAAI;YACA,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAA;SAC/B;QAAC,OAAO,GAAG,EAAE;YACV,OAAO,CAAC,GAAG,CAAC,6BAA6B,CAAC,CAAA;SAC7C;IACL,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,OAAO;QACT,IAAI;YACA,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAA;SAC9B;QAAC,OAAO,GAAG,EAAE;YACV,OAAO,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAA;SACzC;IACL,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,KAAK;QACP,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAA;IAC7B,CAAC;CACJ,CAAA;AAtDY,cAAc;IAD1B,IAAA,qBAAa,EAAC,wBAAsB,CAAC;GACzB,cAAc,CAsD1B;AAtDY,wCAAc","sourcesContent":["import type { ChainablePromiseElement } from 'webdriverio'\n\nimport {\n    PageDecorator, IPageDecorator, BasePage, VSCodeLocatorMap\n} from '../utils'\nimport { TitleBar } from '../..'\nimport { WindowControls as WindowControlsLocators } from '../../locators/1.73.0'\n\nexport interface WindowControls extends IPageDecorator<typeof WindowControlsLocators> {}\n/**\n * Page object for the windows controls part of the title bar\n *\n * @category Menu\n */\n@PageDecorator(WindowControlsLocators)\nexport class WindowControls extends BasePage<typeof WindowControlsLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'WindowControls' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element?: ChainablePromiseElement<WebdriverIO.Element> | string,\n        public bar: TitleBar = new TitleBar(locators)\n    ) {\n        super(locators, element)\n        this.setParentElement(this.bar.elem)\n    }\n\n    /**\n     * Use the minimize window button\n     * @returns Promise resolving when minimize button is pressed\n     */\n    async minimize (): Promise<void> {\n        await this.minimize$.click()\n    }\n\n    /**\n     * Use the maximize window button if the window is not maximized\n     * @returns Promise resolving when maximize button is pressed\n     */\n    async maximize (): Promise<void> {\n        try {\n            await this.maximize$.click()\n        } catch (err) {\n            console.log('Window is already maximized')\n        }\n    }\n\n    /**\n     * Use the restore window button if the window is maximized\n     * @returns Promise resolving when restore button is pressed\n     */\n    async restore (): Promise<void> {\n        try {\n            await this.restore$.click()\n        } catch (err) {\n            console.log('Window is not maximized')\n        }\n    }\n\n    /**\n     * Use the window close button. Use at your own risk.\n     * @returns Promise resolving when close button is pressed\n     */\n    async close (): Promise<void> {\n        await this.close$.click()\n    }\n}\n"]}