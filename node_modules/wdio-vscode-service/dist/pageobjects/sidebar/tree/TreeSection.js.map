{"version":3,"file":"TreeSection.js","sourceRoot":"","sources":["../../../../src/pageobjects/sidebar/tree/TreeSection.ts"],"names":[],"mappings":";;;AAAA,gDAA4C;AAG5C;;GAEG;AACH,MAAsB,WAAY,SAAQ,yBAAW;IACjD,KAAK,CAAC,QAAQ,CAAE,GAAG,IAAc;QAC7B,IAAI,KAAK,GAAe,EAAE,CAAA;QAE1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YACrC,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAA;YAChD,IAAI,MAAM,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC,MAAM,IAAI,EAAE,UAAU,EAAE,EAAE;gBACxD,MAAM,IAAI,EAAE,MAAM,EAAE,CAAA;aACvB;SACJ;QAED,IAAI,WAAW,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;QACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YACrC,IAAI,CAAC,WAAW,EAAE;gBACd,IAAI,CAAC,KAAK,CAAC,EAAE;oBACT,KAAK,GAAG,MAAM,IAAI,CAAC,eAAe,EAAE,CAAA;iBACvC;gBACD,IAAI,KAAK,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAA;gBACnE,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;oBACxB,IAAI,CAAC,GAAG,CAAC,EAAE;wBACP,OAAO,CAAC,CAAA;qBACX;oBACD,IAAI,CAAC,GAAG,CAAC,EAAE;wBACP,OAAO,CAAC,CAAC,CAAA;qBACZ;oBACD,OAAO,CAAC,CAAA;gBACZ,CAAC,CAAC,CAAA;gBACF,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC;oBAC5B,CAAC,CAAC,6BAA6B;oBAC/B,CAAC,CAAC,0CAA0C,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAA;gBAEnE,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,gBAAgB,OAAO,EAAE,CAAC,CAAA;aAC7D;YACD,KAAK,GAAG,MAAM,WAAW,CAAC,WAAW,EAAE,CAAA;YACvC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBAClB,MAAM,WAAW,CAAC,MAAM,EAAE,CAAA;gBAC1B,OAAO,KAAK,CAAA;aACf;YACD,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE;gBACrB,WAAW,GAAG,SAAS,CAAA;gBACvB,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;oBACtB,IAAI,MAAM,IAAI,CAAC,QAAQ,EAAE,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;wBACvC,WAAW,GAAG,IAAI,CAAA;wBAClB,MAAK;qBACR;iBACJ;aACJ;SACJ;QACD,OAAO,KAAK,CAAA;IAChB,CAAC;CAIJ;AArDD,kCAqDC","sourcesContent":["import { ViewSection } from '../ViewSection'\nimport { TreeItem } from '../ViewItem'\n\n/**\n * Abstract representation of a view section containing a tree\n */\nexport abstract class TreeSection extends ViewSection {\n    async openItem (...path: string[]): Promise<TreeItem[]> {\n        let items: TreeItem[] = []\n\n        for (let i = 0; i < path.length; i += 1) {\n            const item = await this.findItem(path[i], i + 1)\n            if (await item?.hasChildren() && !await item?.isExpanded()) {\n                await item?.expand()\n            }\n        }\n\n        let currentItem = await this.findItem(path[0], 1)\n        for (let i = 0; i < path.length; i += 1) {\n            if (!currentItem) {\n                if (i === 0) {\n                    items = await this.getVisibleItems()\n                }\n                let names = await Promise.all(items.map((item) => item.getLabel()))\n                names = names.sort((a, b) => {\n                    if (a > b) {\n                        return 1\n                    }\n                    if (a < b) {\n                        return -1\n                    }\n                    return 0\n                })\n                const message = names.length < 1\n                    ? 'Current directory is empty.'\n                    : `Available items in current directory: [${names.toString()}]`\n\n                throw new Error(`Item '${path[i]}' not found. ${message}`)\n            }\n            items = await currentItem.getChildren()\n            if (items.length < 1) {\n                await currentItem.select()\n                return items\n            }\n            if (i + 1 < path.length) {\n                currentItem = undefined\n                for (const item of items) {\n                    if (await item.getLabel() === path[i + 1]) {\n                        currentItem = item\n                        break\n                    }\n                }\n            }\n        }\n        return items\n    }\n\n    abstract findItem (label: string, maxLevel?: number): Promise<TreeItem | undefined>\n    abstract getVisibleItems (): Promise<TreeItem[]>\n}\n"]}