"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionsViewSection = void 0;
const ViewSection_1 = require("../ViewSection");
const __1 = require("../..");
const utils_1 = require("../../utils");
const _1_73_0_1 = require("../../../locators/1.73.0");
const constants_1 = require("../../../constants");
/**
 * Categories of extensions to search for
 */
var ExtensionCategory;
(function (ExtensionCategory) {
    ExtensionCategory["Installed"] = "@installed";
    ExtensionCategory["Enabled"] = "@enabled";
    ExtensionCategory["Disabled"] = "@disabled";
    ExtensionCategory["Outdated"] = "@outdated";
    ExtensionCategory["Recommended"] = "@recommended";
})(ExtensionCategory || (ExtensionCategory = {}));
/**
 * View section containing extensions
 *
 * @category Sidebar
 */
let ExtensionsViewSection = class ExtensionsViewSection extends ViewSection_1.ViewSection {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = ['ViewSection', 'ExtensionsViewSection'];
    }
    async getVisibleItems() {
        await this.items$.$(this.locators.itemRow).waitForExist({
            timeoutMsg: 'Could not find any extension items'
        });
        const extensionRows = await this.items$.$$(this.locators.itemRow);
        const extensionViewItems = [];
        for (const row of extensionRows) {
            // add implicit wait to avoid stale element exceptions
            // eslint-disable-next-line wdio/no-pause
            await browser.pause(100);
            extensionViewItems.push(
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            await new __1.ExtensionsViewItem(this.locatorMap, row, this).wait());
        }
        return extensionViewItems;
    }
    /**
     * Search for an extension by title. This utilizes the search bar
     * in the Extensions view, which switches the perspective to the
     * section representing the chosen category and temporarily hides all other sections.
     * If you wish to continue working with the initial view section
     * (i.e. Enabled), use the clearSearch method to reset it back to default
     *
     * @param title title to search for in '@category name' format,
     * e.g '@installed extension'. If no @category is present, marketplace will be searched
     *
     * @returns Promise resolving to ExtensionsViewItem if such item exists, undefined otherwise
     */
    async findItem(title) {
        await this.clearSearch();
        const progress = await this.content.progress$;
        const searchField = await this.content.elem.$(this.locators.searchBox);
        await searchField.addValue(title);
        await progress.waitForDisplayed();
        await progress.waitForDisplayed({ reverse: true });
        const sectionTitle = this.getSectionForCategory(title);
        const section = await this.content.getSection(sectionTitle);
        const titleParts = title.split(' ');
        if (titleParts[0].startsWith('@')) {
            title = titleParts.slice(1).join(' ');
        }
        const extensions = await section.getVisibleItems();
        for (const extension of extensions) {
            if (await extension.getTitle() === title) {
                return extension;
            }
        }
        return undefined;
    }
    /**
     * Clears the search bar on top of the view
     * @returns Promise resolving when the search box is cleared
     */
    async clearSearch() {
        const progress = await this.content.progress$;
        const searchField = await this.content.elem.$(this.locators.searchBox);
        const textField = await this.content.elem.$(this.locators.textContainer);
        try {
            await textField.$(this.locators.textField);
            await searchField.addValue([constants_1.CMD_KEY, 'a']);
            await searchField.addValue(['Backspace']);
            await progress.waitForDisplayed();
            await progress.waitForDisplayed({ reverse: true });
        }
        catch (err) {
            // do nothing, the text field is empty
        }
    }
    /**
     * Find and open an extension item
     * @param title title of the extension
     * @returns Promise resolving when the item is clicked
     */
    async openItem(title) {
        const item = await this.findItem(title);
        if (item) {
            await item.elem.click();
        }
        return [];
    }
    getSectionForCategory(title) {
        const category = title.split(' ')[0].toLowerCase();
        switch (category) {
            case ExtensionCategory.Disabled:
                return 'Disabled';
            case ExtensionCategory.Enabled:
                return 'Enabled';
            case ExtensionCategory.Installed:
                return 'Installed';
            case ExtensionCategory.Outdated:
                return 'Outdated';
            case ExtensionCategory.Recommended:
                return 'Other Recommendations';
            default:
                return 'Marketplace';
        }
    }
};
ExtensionsViewSection = __decorate([
    (0, utils_1.PageDecorator)({ ..._1_73_0_1.ViewSection, ..._1_73_0_1.ExtensionsViewSection })
], ExtensionsViewSection);
exports.ExtensionsViewSection = ExtensionsViewSection;
//# sourceMappingURL=ExtensionsViewSection.js.map