{"version":3,"file":"ViewSection.js","sourceRoot":"","sources":["../../../src/pageobjects/sidebar/ViewSection.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ChainablePromiseElement } from 'webdriverio'\n\nimport {\n    ContextMenu, ViewContent, ViewItem, WelcomeContentSection\n} from '..'\nimport {\n    PageDecorator, IPageDecorator, BasePage, ElementWithContextMenu, VSCodeLocatorMap\n} from '../utils'\nimport {\n    ViewSection as ViewSectionLocators,\n    ExtensionsViewSection as ExtensionsViewSectionLocators,\n    CustomTreeSection as CustomTreeSectionLocators,\n    DefaultTreeSection as DefaultTreeSectionLocators\n} from '../../locators/1.73.0'\n\n/**\n * @hidden\n */\nexport type AllViewSectionLocators = (\n    typeof ViewSectionLocators &\n    typeof ExtensionsViewSectionLocators &\n    typeof CustomTreeSectionLocators &\n    typeof DefaultTreeSectionLocators\n)\n\nexport interface ViewSection extends IPageDecorator<AllViewSectionLocators> { }\n/**\n * Page object representing a collapsible content section of the side bar view\n *\n * @category Sidebar\n */\nexport abstract class ViewSection extends BasePage<AllViewSectionLocators> {\n    constructor (\n        locators: VSCodeLocatorMap,\n        panel: ChainablePromiseElement<WebdriverIO.Element>,\n        public content: ViewContent\n    ) {\n        super(locators, panel)\n    }\n\n    /**\n     * Get the title of the section as string\n     * @returns Promise resolving to section title\n     */\n    async getTitle (): Promise<string> {\n        return this.title$.getAttribute(this.locators.titleText)\n    }\n\n    /**\n     * Expand the section if collapsed\n     * @returns Promise resolving when the section is expanded\n     */\n    async expand (): Promise<void> {\n        if (await this.isHeaderHidden()) {\n            return\n        }\n        if (!await this.isExpanded()) {\n            const panel = await this.header$\n            await panel.click()\n            await browser.waitUntil(async () => (\n                await panel.getAttribute(this.locators.headerExpanded) === 'true'\n            ), { timeout: 1000 })\n        }\n    }\n\n    /**\n     * Collapse the section if expanded\n     * @returns Promise resolving when the section is collapsed\n     */\n    async collapse (): Promise<void> {\n        if (await this.isHeaderHidden()) {\n            return\n        }\n        if (await this.isExpanded()) {\n            const panel = await this.header$\n            await panel.click()\n            await browser.waitUntil(async () => (\n                await panel.getAttribute(this.locators.headerExpanded) === 'false'\n            ), { timeout: 1000 })\n        }\n    }\n\n    /**\n     * Finds whether the section is expanded\n     * @returns Promise resolving to true/false\n     */\n    async isExpanded (): Promise<boolean> {\n        const expanded = await this.header$.getAttribute(this.locators.headerExpanded)\n        return expanded === 'true'\n    }\n\n    /**\n     * Finds [Welcome Content](https://code.visualstudio.com/api/extension-guides/tree-view#welcome-content)\n     * present in this ViewSection and returns it. If none is found, then `undefined` is returned\n     *\n     */\n    public async findWelcomeContent (): Promise<WelcomeContentSection | undefined> {\n        try {\n            const res = await this.welcomeContent$\n            if (!await res.isDisplayed()) {\n                return undefined\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            return new WelcomeContentSection(this.locatorMap, res as any, this)\n        } catch (_err) {\n            return undefined\n        }\n    }\n\n    /**\n     * Retrieve all items currently visible in the view section.\n     * Note that any item currently beyond the visible list, i.e. not scrolled to, will not be retrieved.\n     * @returns Promise resolving to array of ViewItem objects\n     */\n    abstract getVisibleItems (): Promise<ViewItem[]>\n\n    /**\n     * Find an item in this view section by label. Does not perform recursive search through the whole tree.\n     * Does however scroll through all the expanded content. Will find items beyond the current scroll range.\n     * @param label Label of the item to search for.\n     * @param maxLevel Limit how deep the algorithm should look into any expanded items, default unlimited (0)\n     * @returns Promise resolving to ViewItem object is such item exists, undefined otherwise\n     */\n    abstract findItem (label: string, maxLevel?: number): Promise<ViewItem | undefined>\n\n    /**\n     * Open an item with a given path represented by a sequence of labels\n     *\n     * e.g to open 'file' inside 'folder', call\n     * openItem('folder', 'file')\n     *\n     * The first item is only searched for directly within the root element (depth 1).\n     * The label sequence is handled in order. If a leaf item (a file for example) is found in the middle\n     * of the sequence, the rest is ignored.\n     *\n     * If the item structure is flat, use the item's title to search by.\n     *\n     * @param path Sequence of labels that make up the path to a given item.\n     * @returns Promise resolving to array of ViewItem objects representing the last item's children.\n     * If the last item is a leaf, empty array is returned.\n     */\n    abstract openItem (...path: string[]): Promise<ViewItem[]>\n\n    /**\n     * Retrieve the action buttons on the section's header\n     * @returns Promise resolving to array of ViewPanelAction objects\n     */\n    async getActions (): Promise<ViewPanelAction[]> {\n        const actions: ViewPanelAction[] = []\n\n        if (!await this.isHeaderHidden()) {\n            const elements = await this\n                .header$\n                .$(this.locators.actions)\n                .$$(this.locators.button)\n\n            for (const element of elements) {\n                actions.push(\n                    await new ViewPanelAction(\n                        this.locatorMap,\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                        element as any,\n                        this\n                    ).wait()\n                )\n            }\n        }\n        return actions\n    }\n\n    /**\n     * Retrieve an action button on the sections's header by its label\n     * @param label label/title of the button\n     * @returns ViewPanelAction object if found, undefined otherwise\n     */\n    async getAction (label: string): Promise<ViewPanelAction | undefined> {\n        const actions = await this.getActions()\n        for (const action of actions) {\n            if (await action.getLabel() === label) {\n                return action\n            }\n        }\n        return undefined\n    }\n\n    /**\n     * Click on the More Actions... item if it exists\n     *\n     * @returns ContextMenu page object if the action succeeds, undefined otherwise\n     */\n    async moreActions (): Promise<ContextMenu | undefined> {\n        const more = await this.getAction('More Actions...')\n        if (!more) {\n            return undefined\n        }\n        const section = this\n        const self = this\n        const btn = new class extends ElementWithContextMenu<typeof ViewSectionLocators> {\n            locatorKey = 'ViewSection' as const\n\n            async openContextMenu () {\n                await this.elem.click()\n                const shadowRootHost = await section.elem.$$('.shadow-root-host')\n                if (shadowRootHost.length > 0) {\n                    const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]))\n                    return new ContextMenu(self.locatorMap, shadowRoot).wait()\n                }\n                return super.openContextMenu()\n            }\n        }(this.locatorMap, more.elem, this.elem)\n        return btn.openContextMenu()\n    }\n\n    private async isHeaderHidden (): Promise<boolean> {\n        return (await this.header$.getAttribute('class')).indexOf('hidden') > -1\n    }\n}\n\nexport interface ViewPanelAction extends IPageDecorator<typeof ViewSectionLocators> { }\n/**\n * Action button on the header of a view section\n *\n * @category Sidebar\n */\n@PageDecorator(ViewSectionLocators)\nexport class ViewPanelAction extends BasePage<typeof ViewSectionLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'ViewSection' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element: ChainablePromiseElement<WebdriverIO.Element>,\n        viewPart: ViewSection\n    ) {\n        super(locators, element, viewPart.elem)\n    }\n\n    /**\n     * Get label of the action button\n     */\n    async getLabel (): Promise<string> {\n        return this.elem.getAttribute(this.locators.buttonLabel)\n    }\n\n    async wait (timeout = 1000): Promise<this> {\n        await this.elem.waitForEnabled({ timeout })\n        return this\n    }\n}\n"]}