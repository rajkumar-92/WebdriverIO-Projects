"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoreAction = exports.ScmChange = exports.ScmProvider = exports.ScmView = void 0;
const SideBarView_1 = require("../SideBarView");
const __1 = require("../..");
const utils_1 = require("../../utils");
const _1_73_0_1 = require("../../../locators/1.73.0");
const constants_1 = require("../../../constants");
/**
 * Page object representing the Source Control view
 *
 * @category Sidebar
 */
let ScmView = class ScmView extends SideBarView_1.SideBarView {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get SCM provider (repository) by title
     * @param title name of the repository
     * @returns promise resolving to ScmProvider object
     */
    async getProvider(title) {
        const providers = await this.getProviders();
        if (!title || providers.length === 1) {
            return providers[0];
        }
        const names = await Promise.all(providers.map(async (item) => item.getTitle()));
        const index = names.findIndex((name) => name === title);
        return index > -1 ? providers[index] : undefined;
    }
    /**
     * Get all SCM providers
     * @returns promise resolving to ScmProvider array
     */
    async getProviders() {
        const headers = await this.providerHeader$$;
        const sections = await Promise.all(headers.map(async (header) => header.$(this.locators.providerRelative)));
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        return Promise.all(sections.map((section) => new ScmProvider(this.locatorMap, section, this)));
    }
    /**
     * Initialize repository in the current folder if no SCM provider is found
     * @returns true if the action was completed succesfully, false if a provider already exists
     */
    async initializeRepository() {
        const buttons = await this.initButton$$;
        if (buttons.length > 0) {
            await buttons[0].click();
            return true;
        }
        return false;
    }
};
ScmView = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], ScmView);
exports.ScmView = ScmView;
/**
 * Page object representing a repository in the source control view
 * Maps roughly to a view section of the source control view
 *
 * @category Sidebar
 */
let ScmProvider = class ScmProvider extends utils_1.BasePage {
    constructor(locators, element, view) {
        super(locators, element, view.elem);
        this.view = view;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get title of the scm provider
     */
    async getTitle() {
        return this.providerTitle$.getAttribute('innerHTML');
    }
    /**
     * Get type of the scm provider (e.g. Git)
     */
    async getType() {
        return this.providerType$.getAttribute('innerHTML');
    }
    /**
     * Find an action button for the SCM provider by title and click it. (e.g 'Commit')
     * @param title Title of the action button to click
     * @returns true if the given action could be performed, false if the button doesn't exist
     */
    async takeAction(title) {
        const header = await this.providerHeader$;
        let actions = [];
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            actions = (await this.view.getTitlePart().getActions()).map((action) => action.elem);
        }
        else {
            await this.elem.moveTo();
            actions = await header.$$(this.locators.action);
        }
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
    /**
     * Open a context menu using the 'More Actions...' button
     * @returns Promise resolving to a ContextMenu object
     */
    async openMoreActions() {
        const header = await this.providerHeader$;
        if ((await header.getAttribute('class')).indexOf('hidden') > -1) {
            return new MoreAction(this.locatorMap, this.view).openContextMenu();
        }
        await this.elem.moveTo();
        return new MoreAction(this.locatorMap, this).openContextMenu();
    }
    /**
     * Fill in the message field and send ctrl/cmd + enter to commit the changes
     * @param message the commit message to use
     * @returns promise resolving once the keypresses are sent
     */
    async commitChanges(message) {
        const input = await this.inputField$;
        await input.clearValue();
        await input.addValue(message);
        await input.addValue([constants_1.CMD_KEY, 'Enter']);
    }
    /**
     * Get page objects for all tree items representing individual changes
     * @param staged when true, finds staged changes otherwise finds unstaged changes
     * @returns promise resolving to ScmChange object array
     */
    async getChanges(staged = false) {
        const changes = await this.getChangeCount(staged);
        const label = staged ? 'STAGED CHANGES' : 'CHANGES';
        let elements = [];
        if (changes > 0) {
            let i = -1;
            elements = await this.changeItem$$;
            for (const [index, item] of elements.entries()) {
                const name = await item.$(this.locators.changeName);
                if (await name.getText() === label) {
                    i = index + 1;
                    break;
                }
            }
            if (i < 0) {
                return [];
            }
            elements = elements.slice(i, i + changes);
        }
        return Promise.all(elements.map((element) => (new ScmChange(this.locatorMap, element, this).wait())));
    }
    /**
     * Get the number of changes for a given section
     * @param staged when true, counts the staged changes, unstaged otherwise
     * @returns promise resolving to number of changes in the given subsection
     */
    async getChangeCount(staged = false) {
        const rows = staged
            ? await this.stagedChanges$$
            : await this.changes$$;
        if (rows.length < 1) {
            return 0;
        }
        const count = await rows[0].$(this.locators.changeCount);
        return +await count.getText();
    }
};
ScmProvider = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], ScmProvider);
exports.ScmProvider = ScmProvider;
/**
 * Page object representing a SCM change tree item
 *
 * @category Sidebar
 */
let ScmChange = class ScmChange extends utils_1.ElementWithContextMenu {
    constructor(locators, row, provider) {
        super(locators, row, provider.elem);
        this.provider = provider;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    /**
     * Get label as a string
     */
    async getLabel() {
        return this.changeLabel$.getText();
    }
    /**
     * Get description as a string
     */
    async getDescription() {
        const desc = await this.changeDesc$$;
        if (desc.length < 1) {
            return '';
        }
        return desc[0].getText();
    }
    /**
     * Get the status string (e.g. 'Modified')
     */
    async getStatus() {
        const res = await this.resource$;
        const status = await res.getAttribute('data-tooltip');
        if (status && status.length > 0) {
            return status;
        }
        return 'folder';
    }
    /**
     * Find if the item is expanded
     * @returns promise resolving to true if change is expanded, to false otherwise
     */
    async isExpanded() {
        const twisties = await this.expand$$;
        if (twisties.length < 1) {
            return true;
        }
        return (await twisties[0].getAttribute('class')).indexOf('collapsed') < 0;
    }
    /**
     * Expand or collapse a change item if possible, only works for folders in hierarchical view mode
     * @param expand true to expand the item, false to collapse
     * @returns promise resolving to true if the item changed state, to false otherwise
     */
    async toggleExpand(expand) {
        if (await this.isExpanded() !== expand) {
            await this.elem.click();
            return true;
        }
        return false;
    }
    /**
     * Find and click an action button available to a given change tree item
     * @param title title of the action button (e.g 'Stage Changes')
     * @returns promise resolving to true if the action was performed successfully,
     * false if the given button does not exist
     */
    async takeAction(title) {
        await this.elem.moveTo();
        const actions = await this.action$$;
        const names = await Promise.all(actions.map((action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
};
ScmChange = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], ScmChange);
exports.ScmChange = ScmChange;
/**
 * More Action
 *
 * @category Sidebar
 */
let MoreAction = class MoreAction extends utils_1.ElementWithContextMenu {
    constructor(locators, scm) {
        super(locators, locators.ScmView.more, scm.elem);
        this.scm = scm;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
    async openContextMenu() {
        await this.elem.click();
        const shadowRootHost = await this.scm.elem.$$('shadow-root-host');
        await browser.keys('Escape');
        if (shadowRootHost.length > 0) {
            if (await this.elem.getAttribute('aria-expanded') !== 'true') {
                await this.elem.click();
            }
            const shadowRoot = $(await browser.execute('return arguments[0].shadowRoot', shadowRootHost[0]));
            return new __1.ContextMenu(this.locatorMap, shadowRoot).wait();
        }
        return super.openContextMenu();
    }
};
MoreAction = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], MoreAction);
exports.MoreAction = MoreAction;
//# sourceMappingURL=ScmView.js.map