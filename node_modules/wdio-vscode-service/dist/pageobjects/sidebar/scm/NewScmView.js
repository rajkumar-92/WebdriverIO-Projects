"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiScmProvider = exports.SingleScmProvider = exports.NewScmView = void 0;
const ScmView_1 = require("./ScmView");
const utils_1 = require("../../utils");
const _1_73_0_1 = require("../../../locators/1.73.0");
const constants_1 = require("../../../constants");
/**
 * New SCM view for code 1.47 onwards
 *
 * @category Sidebar
 */
let NewScmView = class NewScmView extends ScmView_1.ScmView {
    async getProviders() {
        const inputs = await this.inputField$$;
        if (inputs.length < 1) {
            return [];
        }
        const providers = await this.multiScmProvider$$;
        if (inputs.length === 1 && providers.length < 1) {
            return [await new SingleScmProvider(this.locatorMap, this.singleScmProvider$, this).wait()];
        }
        const elements = await this.multiProviderItem$$;
        return Promise.all(elements.map(async (element) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new MultiScmProvider(this.locatorMap, element, this).wait())));
    }
};
NewScmView = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], NewScmView);
exports.NewScmView = NewScmView;
/**
 * Implementation for a single SCM provider
 *
 * @category Sidebar
 */
let SingleScmProvider = class SingleScmProvider extends ScmView_1.ScmProvider {
    /**
     * There is no title available for a single provider
     */
    getTitle() {
        return Promise.resolve('');
    }
    /**
     * No title available for single provider
     */
    getType() {
        return Promise.resolve('');
    }
    async takeAction(title) {
        const view = this.view;
        const buttons = await view.getTitlePart().getActions();
        const names = await Promise.all(buttons.map((button) => button.getTitle()));
        const index = names.findIndex((name) => name === title);
        if (index > -1) {
            await buttons[index].elem.click();
            return true;
        }
        return false;
    }
    async openMoreActions() {
        const view = this.view;
        return new ScmView_1.MoreAction(this.locatorMap, view).openContextMenu();
    }
    async getChanges(staged = false) {
        const count = await this.getChangeCount(staged);
        const elements = [];
        if (count > 0) {
            const header = staged
                ? await this.stagedChanges$
                : await this.changes$;
            const startIndex = +await header.getAttribute('data-index');
            const depth = +await header.getAttribute('aria-level') + 1;
            const items = await this.itemLevel$$(depth);
            for (const item of items) {
                const index = +await item.getAttribute('data-index');
                if (index > startIndex && index <= startIndex + count) {
                    elements.push(item);
                }
            }
        }
        return Promise.all(elements.map(async (element) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new ScmView_1.ScmChange(this.locatorMap, element, this).wait())));
    }
};
SingleScmProvider = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], SingleScmProvider);
exports.SingleScmProvider = SingleScmProvider;
/**
 * Implementation of an SCM provider when multiple providers are available
 *
 * @category Sidebar
 */
let MultiScmProvider = class MultiScmProvider extends ScmView_1.ScmProvider {
    async takeAction(title) {
        const actions = await this.action$$;
        const names = await Promise.all(actions.map(async (action) => action.getAttribute('title')));
        const index = names.findIndex((item) => item === title);
        if (index > -1) {
            await actions[index].click();
            return true;
        }
        return false;
    }
    async openMoreActions() {
        return new MultiMoreAction(this.locatorMap, this).openContextMenu();
    }
    async commitChanges(message) {
        const index = +await this.elem.getAttribute('data-index') + 1;
        const input = await this.view.itemIndex$(index);
        await input.clearValue();
        await input.addValue(message);
        await input.addValue([constants_1.CMD_KEY, 'Enter']);
    }
    async getChanges(staged = false) {
        const count = await this.getChangeCount(staged);
        const elements = [];
        if (count > 0) {
            const index = +await this.elem.getAttribute('data-index');
            const headers = staged
                ? await this.stagedChanges$$
                : await this.changes$$;
            let header;
            for (const item of headers) {
                if (+await item.getAttribute('data-index') > index) {
                    header = item;
                }
            }
            if (!header) {
                return [];
            }
            const startIndex = +await header.getAttribute('data-index');
            const depth = +await header.getAttribute('aria-level') + 1;
            const items = await this.view.itemLevel$$(depth);
            for (const item of items) {
                const indexInner = +await item.getAttribute('data-index');
                if (indexInner > startIndex && indexInner <= startIndex + count) {
                    elements.push(item);
                }
            }
        }
        return Promise.all(elements.map(async (element) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        new ScmView_1.ScmChange(this.locatorMap, element, this).wait())));
    }
    async getChangeCount(staged = false) {
        const locator = staged ? this.locators.stagedChanges : this.locators.changes;
        const rows = await this.view.elem.$$(locator);
        const index = +await this.elem.getAttribute('data-index');
        for (const row of rows) {
            if (+await row.getAttribute('data-index') > index) {
                const count = await rows[0].$(this.locators.changeCount);
                return +await count.getText();
            }
        }
        return 0;
    }
};
MultiScmProvider = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], MultiScmProvider);
exports.MultiScmProvider = MultiScmProvider;
/**
 * Multi More Action
 *
 * @category Sidebar
 */
let MultiMoreAction = class MultiMoreAction extends utils_1.ElementWithContextMenu {
    constructor(locators, scm) {
        super(locators, locators.ScmView.multiMore, scm.elem);
        this.scm = scm;
        /**
         * @private
         */
        this.locatorKey = 'ScmView';
    }
};
MultiMoreAction = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ScmView)
], MultiMoreAction);
//# sourceMappingURL=NewScmView.js.map