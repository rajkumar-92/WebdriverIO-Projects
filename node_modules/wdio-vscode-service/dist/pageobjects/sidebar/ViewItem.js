"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewItemAction = exports.TreeItem = exports.ViewItem = void 0;
const utils_1 = require("../utils");
const _1_73_0_1 = require("../../locators/1.73.0");
/**
 * Arbitrary item in the side bar view
 *
 * @category Sidebar
 */
class ViewItem extends utils_1.ElementWithContextMenu {
    /**
     * Select the item in the view.
     * Note that selecting the item will toggle its expand state when applicable.
     * @returns Promise resolving when the item has been clicked
     */
    async select() {
        await this.elem.click();
    }
}
exports.ViewItem = ViewItem;
/**
 * TreeItem abstract class
 *
 * @category Sidebar
 */
class TreeItem extends ViewItem {
    /**
     * Finds if the item has children by actually counting the child items
     * Note that this will expand the item if it was collapsed
     * @returns Promise resolving to true/false
     */
    async hasChildren() {
        const children = await this.getChildren();
        return children && children.length > 0;
    }
    /**
     * Expands the current item, if it can be expanded and is collapsed.
     */
    async expand() {
        if (await this.isExpandable() && !await this.isExpanded()) {
            await this.twistie$.click();
        }
    }
    /**
     * Find a child item with the given name
     * @returns Promise resolving to TreeItem object if the child item exists, undefined otherwise
     */
    async findChildItem(name) {
        const children = await this.getChildren();
        for (const item of children) {
            if (await item.getLabel() === name) {
                return item;
            }
        }
        return undefined;
    }
    /**
     * Collapse the item if expanded
     */
    async collapse() {
        if (await this.isExpandable() && await this.isExpanded()) {
            await this.twistie$.click();
        }
    }
    /**
     * Find all action buttons bound to the view item
     *
     * @returns array of ViewItemAction objects, empty array if item has no
     * actions associated
     */
    async getActionButtons() {
        await this.elem.moveTo();
        const container = await this.actions$;
        if (!await container.isExisting()) {
            return [];
        }
        const actions = [];
        const items = await container.$$(this.locators.actionLabel);
        for (const item of items) {
            const elem = item.$(this.locatorMap.ViewSection.actionConstructor());
            const label = (
            // v1.69.0 and before
            await elem.getAttribute(this.locators.actionTitle)
                // v1.70.0 and after
                || await item.getAttribute(this.locators.actionTitle));
            actions.push(new ViewItemAction(this.locatorMap, elem, label, this));
        }
        return actions;
    }
    /**
     * Find action button for view item by label
     * @param label label of the button to search by
     *
     * @returns ViewItemAction object if such button exists, undefined otherwise
     */
    async getActionButton(label) {
        const actions = await this.getActionButtons();
        if (actions.length > 0) {
            return actions.find((item) => item.getLabel().indexOf(label) > -1);
        }
        return undefined;
    }
    /**
     * Find all child elements of a tree item
     * @param locator locator of a given type of tree item
     */
    async getChildItems(locator) {
        const items = [];
        await this.expand();
        const rows = await this.parent.$$(locator);
        const baseIndex = +await this.elem.getAttribute(this.locatorMap.ViewSection.index);
        const baseLevel = +await this.elem.getAttribute(this.locatorMap.ViewSection.level);
        for (const row of rows) {
            const level = +await row.getAttribute(this.locatorMap.ViewSection.level);
            const index = +await row.getAttribute(this.locatorMap.ViewSection.index);
            if (index <= baseIndex) {
                continue;
            }
            if (level > baseLevel + 1) {
                continue;
            }
            if (level <= baseLevel) {
                break;
            }
            items.push(row);
        }
        return items;
    }
    async findTwistie() {
        return this.twistie$;
    }
}
exports.TreeItem = TreeItem;
/**
 * Action button bound to a view item
 *
 * @category Sidebar
 */
let ViewItemAction = class ViewItemAction extends utils_1.BasePage {
    constructor(locators, elem, label, viewItem) {
        super(locators, elem, viewItem.elem);
        /**
         * @private
         */
        this.locatorKey = 'ViewSection';
        this.label = label;
    }
    /**
     * Get label of the action button
     */
    getLabel() {
        return this.label;
    }
};
ViewItemAction = __decorate([
    (0, utils_1.PageDecorator)(_1_73_0_1.ViewSection)
], ViewItemAction);
exports.ViewItemAction = ViewItemAction;
//# sourceMappingURL=ViewItem.js.map