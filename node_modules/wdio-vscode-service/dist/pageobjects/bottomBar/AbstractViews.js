"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextView = exports.ChannelView = void 0;
const utils_1 = require("../utils");
/**
 * View with channel selector/**
 *
 * @category BottomBar
 */
class ChannelView extends utils_1.ElementWithContextMenu {
    /**
    * Get names of all selectable channels
    * @returns Promise resolving to array of strings - channel names
    */
    async getChannelNames() {
        const select = await this.parent.$(this.locatorMap.BottomBarViews.outputChannels);
        await select.click();
        // stabelise view otherwise we might run into stale element issues
        // eslint-disable-next-line wdio/no-pause
        await browser.pause(100);
        const channels = await this.parent.$$(`${this.locatorMap.BottomBarViews.outputChannels} option`);
        const names = [];
        for (const channel of channels) {
            names.push(await channel.getAttribute('value'));
        }
        return names;
    }
    /**
     * Get name of the current channel
     * @returns Promise resolving to the current channel name
     */
    async getCurrentChannel() {
        const combo = await this.parent.$(this.locatorMap.BottomBarViews.channelCombo);
        return combo.getAttribute('title');
    }
    /**
     * Select a channel using the selector combo
     * @param name name of the channel to open
     */
    async selectChannel(name) {
        const select = await this.parent.$(this.locatorMap.BottomBarViews.outputChannels);
        await select.click();
        const channels = await this.parent.$$(`${this.locatorMap.BottomBarViews.outputChannels} option`);
        for (const channel of channels) {
            const val = await channel.getValue();
            if (val === name) {
                await channel.click();
                // eslint-disable-next-line wdio/no-pause
                await browser.pause(200);
                await browser.keys(['Escape']);
                return;
            }
        }
        throw new Error(`Channel ${name} not found`);
    }
}
exports.ChannelView = ChannelView;
/**
 * View with channel selection and text area
 */
class TextView extends ChannelView {
    /**
     * Get all text from the currently open channel
     * @returns Promise resolving to the view's text
     */
    async getText() {
        const lines = await this.elem.$(this.locatorMap.OutputView.lines);
        const textLines = await browser.execute((elem) => Array.from(elem.children).map((l) => l.innerText), lines);
        return textLines
            // strip empty lines (usually the last one)
            .filter(Boolean)
            // replace `\u00A0` characters with white space
            // eslint-disable-next-line no-control-regex
            .map((l) => l.replace(/\u00A0/g, ' '));
    }
    /**
     * Clear the text in the current channel
     * @returns Promise resolving when the clear text button is pressed
     */
    async clearText() {
        await this.parent
            .$(this.locatorMap.BottomBarViews.actionsContainer(this.actionsLabel))
            .$(this.locatorMap.BottomBarViews.clearText)
            .click();
    }
}
exports.TextView = TextView;
//# sourceMappingURL=AbstractViews.js.map