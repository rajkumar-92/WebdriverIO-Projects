{"version":3,"file":"ProblemsView.js","sourceRoot":"","sources":["../../../src/pageobjects/bottomBar/ProblemsView.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ChainablePromiseElement } from 'webdriverio'\n\nimport { BottomBarPanel } from '..'\nimport {\n    BasePage, ElementWithContextMenu, PageDecorator, IPageDecorator, VSCodeLocatorMap\n} from '../utils'\nimport { ProblemsView as ProblemsViewLocators, Marker as MarkerLocators } from '../../locators/1.73.0'\n\nexport interface ProblemsView extends IPageDecorator<typeof ProblemsViewLocators> {}\n/**\n * Problems view in the bottom panel.\n *\n * ```ts\n * const bottomBar = workbench.getBottomBar()\n * const outputView = await bottomBar.openProblemsView()\n * console.log(await outputView.setFilter('Error'))\n * ```\n *\n * @category BottomBar\n */\n@PageDecorator(ProblemsViewLocators)\nexport class ProblemsView extends BasePage<typeof ProblemsViewLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'ProblemsView' as const\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        public panel = new BottomBarPanel(locators)\n    ) {\n        super(locators)\n        this.setParentElement(this.panel.elem)\n    }\n\n    /**\n     * Set the filter using the input box on the problems view\n     * @param pattern filter to use, preferably a glob pattern\n     * @returns Promise resolving when the filter pattern is filled in\n     */\n    async setFilter (pattern: string): Promise<void> {\n        const filterField = await this.clearFilter()\n        await filterField.setValue(pattern)\n    }\n\n    /**\n     * Clear all filters\n     * @returns Promise resolving to the filter field WebElement\n     */\n    async clearFilter () {\n        const filterField = await this.panel.elem\n            .$(this.locatorMap.BottomBarPanel.actions as string)\n            .$(this.locators.markersFilter)\n            .$(this.locators.input)\n        await filterField.clearValue()\n        return filterField\n    }\n\n    /**\n     * Collapse all collapsible markers in the problems view\n     * @returns Promise resolving when the collapse all button is pressed\n     */\n    async collapseAll (): Promise<void> {\n        const button = await this.panel.elem\n            .$(this.locatorMap.BottomBarPanel.actions as string)\n            .$(this.locators.collapseAll)\n        await button.click()\n    }\n\n    /**\n     * @deprecated The method should not be used and getAllVisibleMarkers() should be used instead.\n     */\n    async getAllMarkers (): Promise<Marker[]> {\n        return this.getAllVisibleMarkers(MarkerType.Any)\n    }\n\n    /**\n     * Get all visible markers from the problems view with the given type.\n     * Warning: this only returns the markers that are visible, and not the\n     * entire list, so calls to this function may change depending on the\n     * environment  in which the tests are running in.\n     * To get all markers regardless of type, use MarkerType.Any\n     * @param type type of markers to retrieve\n     * @returns Promise resolving to array of Marker objects\n     */\n    async getAllVisibleMarkers (type: MarkerType): Promise<Marker[]> {\n        const markers: Marker[] = []\n        const elements = await this.markerRow$$\n        for (const element of elements) {\n            const isExpandable = typeof (await element.getAttribute('aria-expanded')) === 'string'\n            if (isExpandable) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                const marker = await new Marker(this.locatorMap, element as any, this).wait()\n                if (type === MarkerType.Any || type === await marker.getType()) {\n                    markers.push(marker)\n                }\n                continue\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            markers[markers.length - 1].problems.push(new Problem(this.locatorMap, element as any))\n        }\n        return markers\n    }\n\n    /**\n     * Gets the count badge\n     * @returns Promise resolving to the WebElement representing the count badge\n     */\n    getCountBadge (): Promise<WebdriverIO.Element> {\n        return this.changeCount$\n    }\n}\n\nexport interface Marker extends IPageDecorator<typeof MarkerLocators> {}\n/**\n * Page object for marker in problems view\n *\n * @category BottomBar\n */\n@PageDecorator(MarkerLocators)\nexport class Marker extends ElementWithContextMenu<typeof MarkerLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'Marker' as const\n    public problems: Problem[] = []\n\n    constructor (\n        locators: VSCodeLocatorMap,\n        element: ChainablePromiseElement<WebdriverIO.Element>,\n        public view: ProblemsView\n    ) {\n        super(locators, element, view.elem)\n    }\n\n    /**\n     * Get the type of the marker\n     * Possible types are: File, Error, Warning\n     * @returns Promise resolving to a MarkerType\n     */\n    async getType (): Promise<MarkerType> {\n        const twist = await this.elem.$(this.locatorMap.ProblemsView.markerTwistie as string)\n        if ((await twist.getAttribute('class')).indexOf('collapsible') > -1) {\n            return MarkerType.File\n        }\n        const text = await this.getText()\n        if (text.startsWith('Error')) {\n            return MarkerType.Error\n        }\n\n        return MarkerType.Warning\n    }\n\n    /**\n     * Get the name of the file that has problems\n     * @returns name of file containing problems\n     */\n    getFileName (): Promise<string> {\n        return this.fileName$.getText()\n    }\n\n    /**\n     * Get the error count of the file that has problems\n     * @returns error count of file containing problems\n     */\n    getProblemCount (): Promise<string> {\n        return this.problemCount$.getText()\n    }\n\n    /**\n     * Get the full text of the marker\n     * @returns Promise resolving to marker text\n     */\n    async getText (): Promise<string> {\n        return this.elem.getAttribute(this.locators.rowLabel)\n    }\n\n    /**\n     * Expand/Collapse the marker if possible\n     * @param expand true to expand, false to collapse\n     * @returns Promise resolving when the expand/collapse twistie is clicked\n     */\n    async toggleExpand (expand: boolean): Promise<void> {\n        const klass = await this.markerTwistie$.getAttribute('class')\n        if ((klass.indexOf('collapsed') > -1) === expand) {\n            await this.elem.click()\n        }\n    }\n}\n\nexport interface Problem extends IPageDecorator<typeof MarkerLocators> {}\n/**\n * Page object for marker in problems view\n *\n * @category BottomBar\n */\n@PageDecorator(MarkerLocators)\nexport class Problem extends ElementWithContextMenu<typeof MarkerLocators> {\n    /**\n     * @private\n     */\n    public locatorKey = 'Marker' as const\n\n    /**\n     * Problem details\n     * @returns problem description\n     */\n    getText () {\n        return this.detailsText$.getText()\n    }\n\n    /**\n     * Type of file where the problem is located\n     * @returns source file type\n     */\n    getSource () {\n        return this.detailsSource$.getText()\n    }\n\n    /**\n     * Location problem\n     * @returns location of error as Array [line, column]\n     */\n    async getLocation () {\n        const locationText = await this.detailsLine$.getText()\n        return locationText\n            .slice(1, -1)\n            .split(',')\n            .map((loc) => parseInt(loc.split(' ').pop() as string, 10))\n    }\n\n    /**\n     * Get the type of the marker\n     * Possible types are: File, Error, Warning\n     * @returns Promise resolving to a MarkerType\n     */\n    async getType (): Promise<MarkerType> {\n        const label = await this.elem.getAttribute('aria-label')\n        if (!label) {\n            return MarkerType.Unknown\n        }\n        if (label.startsWith('Error')) {\n            return MarkerType.Error\n        }\n        return MarkerType.Warning\n    }\n}\n\n/**\n * Possible types of markers\n *  - File = expandable item representing a file\n *  - Error = an error marker\n *  - Warning = a warning marker\n *  - Any = any of the above\n *\n * @hidden\n */\nexport enum MarkerType {\n    File = 'file',\n    Unknown = 'unknown',\n    Error = 'error',\n    Warning = 'warning',\n    Any = 'any'\n}\n"]}