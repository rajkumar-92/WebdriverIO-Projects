"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.ElementWithContextMenu = exports.BasePage = exports.PageDecorator = void 0;
const __1 = require("..");
function PageDecorator(locators) {
    return (ctor) => {
        for (const [prop, globalLocator] of Object.entries(locators)) {
            Object.defineProperties(ctor.prototype, {
                [`${prop}$`]: {
                    get: function () {
                        const locator = this.locators[prop] || globalLocator;
                        if (typeof locator === 'function') {
                            return (...args) => this.elem.$(locator(...args));
                        }
                        return this.elem.$(locator);
                    }
                },
                [`${prop}$$`]: {
                    get: function () {
                        const locator = this.locators[prop] || globalLocator;
                        if (typeof locator === 'function') {
                            return (...args) => this.elem.$$(locator(...args));
                        }
                        return this.elem.$$(locator);
                    }
                }
            });
        }
        Object.seal(ctor);
        Object.seal(ctor.prototype);
        return ctor;
    };
}
exports.PageDecorator = PageDecorator;
class BasePage {
    /**
     * @private
     */
    constructor(_locators, _baseElem, _parentElem) {
        this._locators = _locators;
        this._baseElem = _baseElem;
        this._parentElem = _parentElem;
    }
    /**
     * Get the locator map of given page object
     */
    get locators() {
        if (Array.isArray(this.locatorKey)) {
            return this.locatorKey.reduce((prev, locatorKey) => ({
                ...prev,
                ...this._locators[locatorKey]
            }), {});
        }
        return this._locators[this.locatorKey];
    }
    /**
     * @private
     */
    get baseElem() {
        return this._baseElem;
    }
    /**
     * @private
     */
    get locatorMap() {
        return this._locators;
    }
    /**
     * Base element of given page object
     */
    get elem() {
        const baseLocator = this.locators.elem;
        if (this._baseElem) {
            return typeof this._baseElem === 'string'
                ? browser.$(this._baseElem)
                : this._baseElem;
        }
        if (typeof baseLocator === 'string') {
            return browser.$(baseLocator);
        }
        return browser.$('html');
    }
    /**
     * Parent element of given page object
     */
    get parent() {
        if (this._parentElem) {
            return typeof this._parentElem === 'string'
                ? browser.$(this._parentElem)
                : this._parentElem;
        }
        return browser.$('html');
    }
    /**
     * @private
     */
    setParentElement(parentElem) {
        this._parentElem = parentElem;
    }
    /**
     * Wait for the element to become visible
     * @param timeout custom timeout for the wait
     * @returns thenable self reference
     */
    async wait(timeout = 5000) {
        await this.elem.waitForDisplayed({ timeout });
        return this;
    }
}
exports.BasePage = BasePage;
/**
 * Abstract element that has a context menu
 */
class ElementWithContextMenu extends BasePage {
    /**
     * Open context menu on the element
     */
    async openContextMenu() {
        const contextMenuLocators = this.locatorMap.ContextMenu;
        const workbench = browser.$(this.locatorMap.Workbench.elem);
        const menus = await browser.$$(contextMenuLocators.contextView);
        if (menus.length < 1) {
            await this.elem.click({ button: 2 });
            await browser.$(contextMenuLocators.contextView).waitForExist({ timeout: 2000 });
            return new __1.ContextMenu(this.locatorMap, workbench).wait();
        }
        if (await workbench.$$(contextMenuLocators.viewBlock).length > 0) {
            await this.elem.click({ button: 2 });
            await this.elem.waitForDisplayed({ reverse: true, timeout: 1000 });
        }
        await this.elem.click({ button: 2 });
        return new __1.ContextMenu(this.locatorMap).wait();
    }
}
exports.ElementWithContextMenu = ElementWithContextMenu;
function sleep(ms = 500) {
    return new Promise((res) => {
        setTimeout(res, ms);
    });
}
exports.sleep = sleep;
//# sourceMappingURL=utils.js.map