"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = __importDefault(require("fs/promises"));
const util_1 = __importDefault(require("util"));
const path_1 = __importDefault(require("path"));
const slash_1 = __importDefault(require("slash"));
const tmp_promise_1 = __importDefault(require("tmp-promise"));
const logger_1 = __importDefault(require("@wdio/logger"));
const get_port_1 = __importDefault(require("get-port"));
const decamelize_1 = __importDefault(require("decamelize"));
const ws_1 = require("ws");
const webdriverio_1 = require("webdriverio");
const pageobjects_1 = require("./pageobjects");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const log = (0, logger_1.default)('wdio-vscode-service');
class VSCodeWorkerService {
    constructor(_, _capabilities) {
        this._capabilities = _capabilities;
        this._messageId = 0;
        this._pendingMessages = new Map();
        this._isWebSession = false;
        this._vscodeOptions = this._capabilities[constants_1.VSCODE_CAPABILITY_KEY] || {};
        this._proxyOptions = { ...constants_1.DEFAULT_PROXY_OPTIONS, ...this._vscodeOptions.vscodeProxyOptions };
    }
    _handleIncoming(data) {
        try {
            const message = JSON.parse(data.toString('utf-8'));
            const resolver = this._pendingMessages.get(message.id);
            if (!resolver) {
                log.error(`Couldn't find remote message resolver with id ${message.id}`);
                return;
            }
            resolver(message.error, message.result);
            return;
        }
        catch (err) {
            log.error(`Error parsing remote response: ${err.message}`);
        }
    }
    async beforeSession(option, capabilities) {
        this._isWebSession = capabilities.browserName !== 'vscode';
        /**
         * only run setup for VSCode capabilities
         */
        if (!(0, utils_1.isVSCodeCapability)(capabilities)) {
            return;
        }
        /**
         * if we run tests for a web extension
         */
        if (this._isWebSession) {
            const serverOptions = capabilities[constants_1.VSCODE_CAPABILITY_KEY]?.serverOptions;
            option.baseUrl = util_1.default.format('http://%s:%s', serverOptions?.hostname || 'localhost', (serverOptions?.port || constants_1.DEFAULT_VSCODE_WEB_PORT).toString());
            log.info(`Run VSCode as web app on ${option.baseUrl}`);
            return;
        }
        const customArgs = { ...constants_1.VSCODE_APPLICATION_ARGS };
        const storagePath = await tmp_promise_1.default.dir();
        const userSettingsPath = path_1.default.join(storagePath.path, 'settings', 'User');
        const userSettings = {
            ...constants_1.DEFAULT_VSCODE_SETTINGS,
            ...(this._vscodeOptions.userSettings || {})
        };
        if (!this._vscodeOptions.extensionPath) {
            throw new webdriverio_1.SevereServiceError('No extension path provided');
        }
        if (this._proxyOptions.enable) {
            const port = await (0, get_port_1.default)({ port: this._proxyOptions.port });
            userSettings[constants_1.SETTINGS_KEY].port = port;
            log.info(`Start VSCode proxy server on port ${port}`);
            const wss = this._wss = new ws_1.WebSocketServer({ port });
            this._promisedSocket = new Promise((resolve, reject) => {
                const socketTimeout = setTimeout(() => reject(new Error('Connection timeout exceeded')), this._proxyOptions.connectionTimeout);
                wss.on('connection', (socket) => {
                    log.info('Connected with VSCode workbench');
                    resolve(socket);
                    clearTimeout(socketTimeout);
                    socket.on('message', this._handleIncoming.bind(this));
                });
            });
        }
        customArgs.extensionDevelopmentPath = (0, slash_1.default)(this._vscodeOptions.extensionPath);
        customArgs.extensionTestsPath = (0, slash_1.default)(path_1.default.join(__dirname, 'proxy', 'index.js'));
        customArgs.userDataDir = (0, slash_1.default)(path_1.default.join(storagePath.path, 'settings'));
        customArgs.extensionsDir = (0, slash_1.default)(path_1.default.join(storagePath.path, 'extensions'));
        customArgs.vscodeBinaryPath = this._vscodeOptions.binary;
        log.info(`Setting up VSCode directory at ${userSettingsPath}`);
        await promises_1.default.mkdir(userSettingsPath, { recursive: true });
        await promises_1.default.writeFile(path_1.default.join(userSettingsPath, 'settings.json'), JSON.stringify(userSettings), 'utf-8');
        if (this._vscodeOptions.workspacePath) {
            customArgs.folderUri = `file:${(0, slash_1.default)(this._vscodeOptions.workspacePath)}`;
        }
        if (this._vscodeOptions.filePath) {
            customArgs.fileUri = `file:${(0, slash_1.default)(this._vscodeOptions.filePath)}`;
        }
        if (this._vscodeOptions.verboseLogging) {
            customArgs.verbose = true;
            customArgs.logExtensionHostCommunication = true;
        }
        const binary = path_1.default.join(__dirname, 'chromium', `index.${process.platform === 'win32' ? 'exe' : 'js'}`);
        const args = Object.entries({ ...customArgs, ...this._vscodeOptions.vscodeArgs }).reduce((prev, [key, value]) => [
            ...prev,
            `--${(0, decamelize_1.default)(key, { separator: '-' })}${(0, utils_1.getValueSuffix)(value)}`
        ], []);
        /**
         * need to rename capability back to Chrome otherwise Chromedriver
         * won't recognise this capability
         */
        capabilities.browserName = 'chrome';
        capabilities['goog:chromeOptions'] = { binary, args, windowTypes: ['webview'] };
        log.info(`Start VSCode: ${binary} ${args.join(' ')}`);
    }
    async before(capabilities, __, browser) {
        /**
         * only run setup for VSCode capabilities
         */
        if (!(0, utils_1.isVSCodeCapability)(capabilities)) {
            return;
        }
        /**
         * open VSCode web when testing web extensions
         */
        if (this._isWebSession) {
            await browser.url('/');
        }
        this._browser = browser;
        const locators = await (0, utils_1.getLocators)(capabilities.browserVersion || 'insiders');
        const workbenchPO = new pageobjects_1.Workbench(locators);
        this._browser.addCommand('getWorkbench', () => workbenchPO.wait());
        this._browser.addCommand('executeWorkbench', this._executeVSCode.bind(this));
        this._browser.addCommand('getVSCodeVersion', () => capabilities.browserVersion);
        this._browser.addCommand('isVSCodeWebSession', () => this._isWebSession);
        this._browser.addCommand('getVSCodeChannel', () => (capabilities.browserVersion === 'insiders' ? 'insiders' : 'vscode'));
        await workbenchPO.elem.waitForExist();
        /**
         * VSCode in the browser doesn't allow to have a file directly opened,
         * therefore we need to open it automatically
         */
        if (this._isWebSession && this._vscodeOptions.filePath && this._vscodeOptions.workspacePath) {
            const sections = this._vscodeOptions.filePath.replace(this._vscodeOptions.workspacePath, '')
                .split(path_1.default.sep).filter(Boolean);
            const fileExplorer = await browser.$('.explorer-folders-view');
            while (sections.length > 0) {
                const entry = sections.shift();
                await fileExplorer.$(`span=${entry}`).click();
            }
        }
    }
    async after() {
        if (!(0, utils_1.isVSCodeCapability)(this._capabilities)
            || !this._browser
            || !this._capabilities[constants_1.VSCODE_CAPABILITY_KEY]?.verboseLogging) {
            return;
        }
        const logs = await this._browser.getLogs('browser').then((res) => res, (err) => err);
        if (logs instanceof Error) {
            return;
        }
        for (const l of logs) {
            log.info(`[${(new Date(l.timestamp)).toISOString()}]`
                + ` - ${l.source} - ${l.message}`);
        }
        if (this._wss) {
            this._wss.close();
        }
    }
    async _executeVSCode(fn, ...params) {
        if (!this._promisedSocket || this._isWebSession) {
            const errorMessage = this._isWebSession
                ? 'not support when testing web extensions'
                : 'see "vscodeProxyOptions" option in service docs';
            throw new Error(`VSCode API proxy not enabled, ${errorMessage}`);
        }
        const socket = await this._promisedSocket;
        const proxyFn = typeof fn === 'function'
            ? fn.toString()
            : fn;
        socket.send(JSON.stringify({
            id: this._messageId,
            fn: proxyFn,
            params
        }));
        const returnVal = new Promise((resolve, reject) => {
            const cmdTimeout = setTimeout(() => reject(new Error('Remote command timeout exceeded')), this._proxyOptions.commandTimeout);
            this._pendingMessages.set(this._messageId, (error, result) => {
                clearTimeout(cmdTimeout);
                if (error) {
                    reject(new Error(error));
                    return;
                }
                resolve(result);
            });
        });
        this._messageId += 1;
        return returnVal;
    }
}
exports.default = VSCodeWorkerService;
//# sourceMappingURL=service.js.map