"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const download_1 = __importDefault(require("download"));
const logger_1 = __importDefault(require("@wdio/logger"));
const undici_1 = require("undici");
const test_electron_1 = require("@vscode/test-electron");
const webdriverio_1 = require("webdriverio");
const wdio_chromedriver_service_1 = require("wdio-chromedriver-service");
const server_1 = __importDefault(require("./server"));
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const VERSIONS_TXT = 'versions.txt';
const log = (0, logger_1.default)('wdio-vscode-service/launcher');
class VSCodeServiceLauncher extends wdio_chromedriver_service_1.launcher {
    constructor(_options, _capabilities, config) {
        super(_options, _capabilities, config);
        this._options = _options;
        this._capabilities = _capabilities;
        this._cachePath = this._options.cachePath || constants_1.DEFAULT_CACHE_PATH;
        this._mapCapabilities = () => { };
    }
    // @ts-expect-error this service uses provided params
    async onPrepare(_, capabilities) {
        const caps = Array.isArray(capabilities)
            ? capabilities.map((c) => (c.alwaysMatch || c))
            : Object.values(capabilities).map((c) => c.capabilities);
        /**
         * check if for given version we already have all bundles
         * and continue without download if possible
         */
        const versionsFilePath = path_1.default.join(this._cachePath, VERSIONS_TXT);
        const versionsFileExist = await (0, utils_1.fileExist)(versionsFilePath);
        for (const cap of caps) {
            /**
             * skip setup if user is not using VSCode as capability
             */
            if (typeof cap.browserName !== 'string' || !cap[constants_1.VSCODE_CAPABILITY_KEY]) {
                continue;
            }
            const version = cap[constants_1.VSCODE_CAPABILITY_KEY].version || cap.browserVersion || constants_1.DEFAULT_CHANNEL;
            /**
             * setup VSCode Desktop
             */
            if (cap.browserName === 'vscode') {
                await this._setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap);
                continue;
            }
            /**
             * setup VSCode Web
             */
            await this._setupVSCodeWeb(version, cap);
            // @ts-expect-error CJS
            const instance = await this.instance;
            this._mapBrowserCapabilities(instance.options);
        }
        return super.onPrepare();
    }
    /**
     * Set up VSCode for web testing
     * @param versionsFileExist true if we already have information stored about cached VSCode and Chromedriver bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeWeb(version, cap) {
        /**
         * no need to do any work if we already started the server
         */
        if (this._vscodeServerPort || !cap[constants_1.VSCODE_CAPABILITY_KEY]) {
            return;
        }
        try {
            const vscodeStandalone = await this._fetchVSCodeWebStandalone(version);
            const port = await (0, server_1.default)(vscodeStandalone, cap[constants_1.VSCODE_CAPABILITY_KEY]);
            cap[constants_1.VSCODE_CAPABILITY_KEY].serverOptions = {
                ...(cap[constants_1.VSCODE_CAPABILITY_KEY].serverOptions || {
                    hostname: constants_1.DEFAULT_VSCODE_WEB_HOSTNAME
                }),
                port
            };
        }
        catch (err) {
            throw new webdriverio_1.SevereServiceError(`Couldn't start server for VSCode Web: ${err.message}`);
        }
    }
    /**
     * Set up VSCode for desktop testing
     * @param versionsFileExist true if we already have information stored about cached VSCode and Chromedriver bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap) {
        if (!cap[constants_1.VSCODE_CAPABILITY_KEY]) {
            throw new Error(`No key "${constants_1.VSCODE_CAPABILITY_KEY}" found in caps`);
        }
        // @ts-expect-error CJS
        const instance = await this.instance;
        if (versionsFileExist) {
            const content = JSON.parse((await promises_1.default.readFile(versionsFilePath)).toString());
            const chromedriverPath = path_1.default.join(this._cachePath, `chromedriver-${content[version]?.chromedriver}`);
            const vscodePath = (cap[constants_1.VSCODE_CAPABILITY_KEY]?.binary
                || path_1.default.join(this._cachePath, `vscode-${process.platform}-${content[version]?.vscode}`));
            if (content[version] && await (0, utils_1.fileExist)(chromedriverPath) && await (0, utils_1.fileExist)(vscodePath)) {
                log.info(`Skipping download, bundles for VSCode v${content[version]?.vscode} `
                    + `and Chromedriver v${content[version]?.chromedriver} already exist`);
                Object.assign(cap, instance.options);
                cap[constants_1.VSCODE_CAPABILITY_KEY].binary = (cap[constants_1.VSCODE_CAPABILITY_KEY].binary
                    || await this._downloadVSCode(content[version]?.vscode));
                instance.chromedriverCustomPath = chromedriverPath;
                return;
            }
        }
        const [vscodeVersion, chromedriverVersion, chromedriverPath] = await this._setupChromedriver(version);
        instance.chromedriverCustomPath = chromedriverPath;
        const serviceArgs = {
            chromedriver: { version: chromedriverVersion, path: chromedriverPath },
            vscode: {
                version: vscodeVersion,
                path: cap[constants_1.VSCODE_CAPABILITY_KEY]?.binary || await this._downloadVSCode(vscodeVersion)
            }
        };
        Object.assign(cap, instance.options);
        cap[constants_1.VSCODE_CAPABILITY_KEY].binary = serviceArgs.vscode.path;
        await this._updateVersionsTxt(version, serviceArgs, versionsFileExist);
    }
    /**
     * Downloads Chromedriver bundle for given VSCode version
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "insiders" if `desiredReleaseChannel` is set to this otherwise a concrete version
     */
    async _setupChromedriver(desiredReleaseChannel) {
        const version = await this._fetchVSCodeVersion(desiredReleaseChannel);
        try {
            const chromedriverVersion = await this._fetchChromedriverVersion(version);
            log.info(`Download Chromedriver (v${chromedriverVersion})`);
            await (0, download_1.default)((0, util_1.format)(constants_1.CHROMEDRIVER_DOWNLOAD_PATH, chromedriverVersion, (0, utils_1.validatePlatform)()), this._cachePath, { extract: true, strip: 1 });
            const ext = os_1.default.platform().startsWith('win') ? '.exe' : '';
            const chromedriverPath = path_1.default.join(this._cachePath, `chromedriver-${chromedriverVersion}${ext}`);
            await promises_1.default.rename(path_1.default.join(this._cachePath, `chromedriver${ext}`), chromedriverPath);
            /**
             * return 'insiders' if desired release channel
             */
            return version === 'main'
                ? [desiredReleaseChannel, chromedriverVersion, chromedriverPath]
                : [version, chromedriverVersion, chromedriverPath];
        }
        catch (err) {
            throw new webdriverio_1.SevereServiceError(`Couldn't set up Chromedriver ${err.message}`);
        }
    }
    /**
     * Download VSCode bundle
     * @param version VSCode version
     * @returns path to downloaded VSCode bundle
     */
    async _downloadVSCode(version) {
        try {
            log.info(`Download VSCode binary (${version})`);
            return await (0, test_electron_1.download)({
                cachePath: this._cachePath,
                version
            });
        }
        catch (err) {
            throw new webdriverio_1.SevereServiceError(`Couldn't set up VSCode: ${err.message}`);
        }
    }
    /**
     * Get VSCode version based on desired channel or validate version if provided
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "main" if `desiredReleaseChannel` is "insiders" otherwise a concrete VSCode version
     */
    async _fetchVSCodeVersion(desiredReleaseChannel) {
        if (desiredReleaseChannel === 'insiders') {
            return 'main';
        }
        try {
            log.info(`Fetch releases from ${constants_1.VSCODE_RELEASES}`);
            const { body: versions } = await (0, undici_1.request)(constants_1.VSCODE_RELEASES, {});
            const availableVersions = await versions.json();
            if (desiredReleaseChannel) {
                /**
                 * validate provided VSCode version
                 */
                const newDesiredReleaseChannel = desiredReleaseChannel === 'stable'
                    ? availableVersions[0]
                    : desiredReleaseChannel;
                if (!availableVersions.includes(newDesiredReleaseChannel)) {
                    throw new Error(`Desired version "${newDesiredReleaseChannel}" is not existent, available versions:`
                        + `${availableVersions.slice(0, 5).join(', ')}..., see ${constants_1.VSCODE_RELEASES}`);
                }
                return newDesiredReleaseChannel;
            }
            return availableVersions[0];
        }
        catch (err) {
            throw new webdriverio_1.SevereServiceError(`Couldn't fetch latest VSCode: ${err.message}`);
        }
    }
    /**
     * Fetches required Chromedriver version for given VSCode version
     * @param vscodeVersion branch or tag version of VSCode repository
     * @returns required Chromedriver version
     */
    async _fetchChromedriverVersion(vscodeVersion) {
        try {
            const { body } = await (0, undici_1.request)((0, util_1.format)(constants_1.VSCODE_MANIFEST_URL, vscodeVersion), {});
            const manifest = await body.json();
            const chromium = manifest.registrations.find((r) => r.component.git.name === 'chromium');
            if (!chromium) {
                throw new Error('Can\'t find chromium version in manifest response');
            }
            const { body: chromedriverVersion } = await (0, undici_1.request)((0, util_1.format)(constants_1.CHROMEDRIVER_RELEASES, chromium.version.split('.')[0]), {});
            return await chromedriverVersion.text();
        }
        catch (err) {
            throw new webdriverio_1.SevereServiceError(`Couldn't fetch Chromedriver version: ${err.message}`);
        }
    }
    /**
     * Fetches VSCode Web files
     * ToDo(Christian): allow to define a local VSCode development path
     *                  to be able to skip this part
     */
    async _fetchVSCodeWebStandalone(vscodeVersion) {
        if (vscodeVersion !== 'stable' && vscodeVersion !== 'insiders') {
            throw new Error('Running VSCode in the browser is only supported for "stable" and "insiders" version');
        }
        try {
            const { body } = await (0, undici_1.request)((0, util_1.format)(constants_1.VSCODE_WEB_STANDALONE, vscodeVersion), {});
            const info = await body.json();
            const folder = path_1.default.join(this._cachePath, `vscode-web-${vscodeVersion}-${info.version}`);
            if (!(await (0, utils_1.directoryExists)(folder))) {
                await (0, download_1.default)(info.url, folder, { extract: true, strip: 1 });
            }
            return { path: folder, vscodeVersion, version: info.version };
        }
        catch (err) {
            throw new webdriverio_1.SevereServiceError(`Couldn't set up VSCode Web: ${err.message}`);
        }
    }
    async _updateVersionsTxt(version, serviceArgs, versionsFileExist) {
        const newContent = {
            [version]: {
                chromedriver: serviceArgs.chromedriver.version,
                vscode: serviceArgs.vscode.version
            }
        };
        const versionsTxtPath = path_1.default.join(this._cachePath, VERSIONS_TXT);
        if (!versionsFileExist) {
            return promises_1.default.writeFile(versionsTxtPath, JSON.stringify(newContent, null, 4), 'utf-8');
        }
        const content = JSON.parse((await promises_1.default.readFile(versionsTxtPath, 'utf-8')).toString());
        return promises_1.default.writeFile(versionsTxtPath, JSON.stringify({ ...content, ...newContent }, null, 4), 'utf-8');
    }
    _mapBrowserCapabilities(options) {
        if ((0, utils_1.isMultiremote)(this._capabilities)) {
            throw new webdriverio_1.SevereServiceError('This service deson\'t support multiremote yet');
        }
        for (const cap of this._capabilities) {
            if ((0, utils_1.isChrome)(cap)) {
                Object.assign(cap, options);
            }
        }
    }
}
exports.default = VSCodeServiceLauncher;
//# sourceMappingURL=launcher.js.map