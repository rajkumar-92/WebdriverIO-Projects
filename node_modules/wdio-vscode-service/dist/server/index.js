"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const logger_1 = __importDefault(require("@wdio/logger"));
const get_port_1 = __importDefault(require("get-port"));
const fastify_1 = __importDefault(require("fastify"));
const cors_1 = __importDefault(require("@fastify/cors"));
const static_1 = __importDefault(require("@fastify/static"));
const undici_1 = require("undici");
const workbench_tpl_1 = __importDefault(require("./workbench.tpl"));
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const constants_1 = require("./constants");
const constants_2 = require("../constants");
const log = (0, logger_1.default)('wdio-vscode-service/server');
const mountPrefix = '/static/mount';
const webviewHostRegexp = /^https:\/\/[^.]+\.vscode-webview\.net$/;
/**
 * ToDo(Christian): missing capabilities:
 *   - allow serve VSCode sources from path location or CDN
 *   - allow to include additional extensions (#20)
 */
async function startServer(standalone, options) {
    const app = (0, fastify_1.default)({ logger: true });
    const port = await (0, get_port_1.default)({ port: options.serverOptions?.port || constants_2.DEFAULT_VSCODE_WEB_PORT });
    await app.register(cors_1.default, {
        methods: ['GET'],
        credentials: true,
        origin: (origin, cb) => cb(null, webviewHostRegexp.test(origin))
    });
    app.addHook('preHandler', async (req, reply) => {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        reply.header('Access-Control-Allow-Origin', '*');
        const value = req.query['vscode-coi'];
        if (value === '1') {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            reply.header('Cross-Origin-Opener-Policy', 'same-origin');
        }
        else if (value === '2') {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            reply.header('Cross-Origin-Embedder-Policy', 'require-corp');
        }
        else if (value === '3' || value === '') {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            reply.header('Cross-Origin-Opener-Policy', 'same-origin');
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            reply.header('Cross-Origin-Embedder-Policy', 'require-corp');
        }
    });
    if (options.extensionPath) {
        log.info(`Serving dev extensions from ${options.extensionPath}`);
        await app.register(static_1.default, {
            prefix: '/static/devextensions',
            root: options.extensionPath
        });
    }
    await app.register(static_1.default, {
        prefix: '/static/build',
        root: standalone.path,
        decorateReply: false // the reply decorator has been added by the first plugin registration
    });
    if (options.workspacePath) {
        log.info(`Serve workspace from ${options.workspacePath}`);
        app.addHook('preHandler', async (req, reply) => {
            const filePath = req.params['*'];
            const queries = Object.keys(req.query);
            if (!options.workspacePath || !filePath || !req.url.startsWith(mountPrefix)) {
                return null;
            }
            const p = path_1.default.join(options.workspacePath, filePath === mountPrefix.slice(1)
                ? filePath.slice(mountPrefix.length - 1)
                : filePath);
            if (queries.includes('stat')) {
                try {
                    const stats = await promises_1.default.stat(p);
                    // eslint-disable-next-line @typescript-eslint/return-await
                    return reply.send(JSON.stringify({
                        type: (0, utils_2.getFileType)(stats),
                        ctime: stats.ctime.getTime(),
                        mtime: stats.mtime.getTime(),
                        size: stats.size
                    }));
                }
                catch (e) {
                    log.warn(e.stack);
                    return reply.send(JSON.stringify({
                        error: e.code
                    }));
                }
            }
            if (queries.includes('readdir')) {
                try {
                    const entries = await promises_1.default.readdir(p, { withFileTypes: true });
                    // eslint-disable-next-line @typescript-eslint/return-await
                    return reply.send(JSON.stringify(entries.map((d) => ({ name: d.name, type: (0, utils_2.getFileType)(d) }))));
                }
                catch (e) {
                    log.warn(e.stack);
                    return reply.send(JSON.stringify({
                        error: e.code
                    }));
                }
            }
            return null;
        });
        await app.register(static_1.default, {
            prefix: `${mountPrefix}/`,
            root: options.workspacePath,
            dotfiles: 'allow',
            decorateReply: false // the reply decorator has been added by the first plugin registration
        });
        await app.register(static_1.default, {
            prefix: constants_1.fsProviderExtensionPrefix,
            root: path_1.default.join(__dirname, '..', '..', 'src', 'server', 'fs-provider'),
            decorateReply: false // the reply decorator has been added by the first plugin registration
        });
    }
    /**
     * mount additional extensions here, e.g.:
     * ```
     * if (config.extensionPaths) {
     *   config.extensionPaths.forEach((extensionPath, index) => {
     *     console.log('Serving additional built-in extensions from ' + extensionPath);
     *     app.use(kmount(`/static/extensions/${index}`, kstatic(extensionPath, serveOptions)));
     *   });
     * }
     * ```
     * when working on https://github.com/webdriverio-community/wdio-vscode-service/issues/20
     */
    /**
     * Workbench
     */
    app.get('/callback', async (req, reply) => {
        const host = `${req.protocol}://${req.hostname || constants_2.DEFAULT_VSCODE_WEB_HOSTNAME}:${port}`;
        const url = `${host}/${req.url}/out/vs/code/browser/workbench/callback.html`;
        const { body } = await (0, undici_1.request)(url, {});
        await reply.send(body);
    });
    app.get('/', async (req, reply) => {
        const hostname = req.hostname || constants_2.DEFAULT_VSCODE_WEB_HOSTNAME;
        const host = `${req.protocol}://${hostname}`;
        const webConfiguration = await (0, utils_1.getWorkbenchOptions)({ protocol: req.protocol, host: hostname }, {
            /**
             * modify when support additional extension
             */
            extensionPaths: [],
            extensionIds: [],
            extensionDevelopmentPath: options.extensionPath,
            build: {
                type: 'static',
                location: standalone.path,
                quality: (options.version || constants_2.DEFAULT_CHANNEL),
                version: standalone.version
            },
            extensionTestsPath: undefined,
            folderUri: undefined,
            folderMountPath: options.workspacePath,
            printServerLog: true
        });
        const template = (0, workbench_tpl_1.default)({
            baseUrl: `${host}/static/build`,
            webConfiguration: JSON.stringify(webConfiguration).replace(/"/g, '&quot;'),
            authSession: '',
            builtinExtensions: '[]'
        });
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        reply.header('Content-Type', 'text/html');
        return reply.send(template);
    });
    await app.listen(port);
    log.info(`VSCode server started on port ${port}`);
    return port;
}
exports.default = startServer;
//# sourceMappingURL=index.js.map